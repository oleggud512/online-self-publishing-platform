
firebase_options.dart

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBQx-7ZGkxi08pNR4exenZEcn-zjBCtUco',
    appId: '1:626801727731:web:ec3b4f2c203f7dcbf03f86',
    messagingSenderId: '626801727731',
    projectId: 'books-course-work-1',
    authDomain: 'books-course-work-1.firebaseapp.com',
    storageBucket: 'books-course-work-1.appspot.com',
    measurementId: 'G-780FFYWGGL',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAVrmV93zGY_JVACAME5lqEIrcoisN-mqM',
    appId: '1:626801727731:android:52fd54b3dbc1be4ff03f86',
    messagingSenderId: '626801727731',
    projectId: 'books-course-work-1',
    storageBucket: 'books-course-work-1.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyBqDXLswLpWWT7Bp4zvHkytsLha08BeMXI',
    appId: '1:626801727731:ios:25cb4bf0692be799f03f86',
    messagingSenderId: '626801727731',
    projectId: 'books-course-work-1',
    storageBucket: 'books-course-work-1.appspot.com',
    iosClientId: '626801727731-umlvit2f1tiqmqbddrsa3c32nq19cb8t.apps.googleusercontent.com',
    iosBundleId: 'com.example.client',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyBqDXLswLpWWT7Bp4zvHkytsLha08BeMXI',
    appId: '1:626801727731:ios:25cb4bf0692be799f03f86',
    messagingSenderId: '626801727731',
    projectId: 'books-course-work-1',
    storageBucket: 'books-course-work-1.appspot.com',
    iosClientId: '626801727731-umlvit2f1tiqmqbddrsa3c32nq19cb8t.apps.googleusercontent.com',
    iosBundleId: 'com.example.client',
  );
}


main.dart

import 'dart:convert';

import 'package:client/firebase_options.dart';
import 'package:client/src/app.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/data/auth_repository.dart';
import 'package:client/src/features/books/application/local_bookmarks_provider.dart';
import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:client/src/features/notifications/data/notification_service.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/dio.dart';
import 'package:client/src/shared/sembast.dart';
import 'package:dio/dio.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stack_trace/stack_trace.dart' as stack_trace;
import 'package:firebase_core/firebase_core.dart';


void main(List<String> arguments) async {
  await dotenv.load();
    
  WidgetsFlutterBinding.ensureInitialized();
  FlutterError.demangleStackTrace = (StackTrace stack) {
    if (stack is stack_trace.Trace) return stack.vmTrace;
    if (stack is stack_trace.Chain) return stack.toTrace().vmTrace;
    return stack;
  };

  final container = ProviderContainer(
    overrides: [ ]
  );
  
  // initialize localization - load current locale
  await container.read(localizationControllerProvider.notifier).loadLocale();
  // create sembast database instance
  await container.read(sembastDatabaseFutureProvider.future);
  // initialize bookmarks - start observing local bookmarks
  container.read(localBookmarksControllerProvider);

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  final token = 
    await container.read(authRepositoryProvider).currentUser?.getIdToken(true);

  await NotificationService.requestPermissions();
  await NotificationService.init();

  try {
    if (token != null) {
      await NotificationService.syncToken(container.read(dioProvider));
    }
  } on DioError catch (e) {
    if (e.response?.data['error']['code'] == 'blockedUserAuth') {
      container.read(routerProvider).goNamed(MyRoute.blocked.name);
    }  
  } on FirebaseAuthException catch (e) {
    printInfo(e.code);
    if (e.code == 'firebase_auth/user-token-expired') {
      container.read(routerProvider).goNamed(MyRoute.blocked.name);
    }
  }
  
  runApp(UncontrolledProviderScope(
    container: container,
    child: const MyApp()
  ));
}


create_file.py

import os

def create_single_file(file_name):
    # Get the current directory path
    current_dir = os.getcwd()
    
    # Initialize an empty string to hold the file contents
    file_contents = ''
    
    # Loop through all subdirectories and files
    for root, dirs, files in os.walk(current_dir):
        for file in files:
            # Exclude files ending in ".freezed.dart" or ".g.dart"
            if not file.endswith(('.freezed.dart', '.g.dart')):
                # Get the file path relative to the current working directory and read its contents
                file_path = os.path.relpath(os.path.join(root, file), current_dir)
                with open(os.path.join(root, file), 'r') as f:
                    contents = f.read()
                
                # Add the file path and contents to the output string
                file_contents += f"\n{file_path}\n\n{contents}\n"
    
    # Write the output string to the specified file
    with open(file_name, 'w') as f:
        f.write(file_contents)

create_single_file('output.txt')

src/app.dart

import 'package:client/src/router/router.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import 'features/localization/data/localization_controller.dart';
import 'features/localization/data/localization_state.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ThemeData theme = ThemeData(
      useMaterial3: true, 
      colorSchemeSeed: Colors.brown,
      inputDecorationTheme: const InputDecorationTheme(
        border: OutlineInputBorder()
      ),
      navigationBarTheme: NavigationBarThemeData(
        labelTextStyle: MaterialStatePropertyAll(
          Theme.of(context).textTheme.labelMedium!.copyWith(
            overflow: TextOverflow.ellipsis
          )
        )
      ),
    );
    GoRouter router = ref.watch(routerProvider);
    GlobalKey<ScaffoldMessengerState> scaffoldMessengerState = 
      ref.watch(scaffoldMessangerStateProvider);

    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      
      scaffoldMessengerKey: scaffoldMessengerState,
      
      routerConfig: router,

      localizationsDelegates: 
        ref.watch(localizationControllerProvider.notifier).getDelegates(),
      supportedLocales: SupportedLocale.values.map((v) => Locale(v)),
      locale: ref.watch(localizationControllerProvider).locale,

      theme: theme
    );
  }
}

src/features/settings/presentation/settings_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/localization/application/current_locale.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:client/src/features/localization/data/localization_state.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../auth/data/auth_repository.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ll = ref.watch(currentLocalizationProvider);
    return Scaffold(
      appBar: AppBar(
        title: Text(ll.screenTitle.settings),
        centerTitle: true,
      ), 
      body: ListView(
        padding: const EdgeInsets.all(p16),
        children: [
          DropdownButtonFormField(
            decoration: InputDecoration(
              labelText: ll.settings.changeLanguageLabel
            ),
            value: ref.watch(currentLocaleProvider),
            items: [
              DropdownMenuItem(
                value: const Locale('en'),
                child: Text(ll.settings.english()),
              ),
              DropdownMenuItem(
                value: const Locale('uk'),
                child: Text(ll.settings.ukrainian()),
              ),
            ], 
            onChanged: (nv) {
              ref.read(localizationControllerProvider.notifier)
                .changeLocale(nv!).then((v) {
                  final newLl = ref.watch(currentLocalizationProvider);
                  ref.read(scaffoldMessangerStateProvider).showMessage(
                    newLl.settings.onLangChangedLabel(
                      nv.languageCode == SupportedLocale.en
                        ? newLl.settings.english(true)
                        : newLl.settings.ukrainian(true),
                    ),
                  );
                });
            }
          ),
          h8gap,
          
          if (ref.watch(myIdProvider) != null) 
            FilledButton.icon(
              icon: const Icon(Icons.logout),
              label: Text("Sign Out".hardcoded),
              onPressed: () async {
                await ref.watch(authRepositoryProvider).signOut();
                if (context.mounted) context.goNamed(MyRoute.auth.name);
              }, 
            )
          else 
            FilledButton.icon(
              icon: const Icon(Icons.login),
              label: Text("Sign In".hardcoded),
              onPressed: () => context.goNamed(MyRoute.auth.name)
            )
        ]
      )
    );
  }
}

src/features/home/presentation/home_screen_app_bar.dart

import 'package:client/src/features/localization/application/ll.dart';
import 'package:client/src/router/menu_button_leading.dart';
import 'package:flutter/material.dart';

class HomeScreenAppBar extends StatelessWidget with PreferredSizeWidget {
@override
  final Size preferredSize;

  HomeScreenAppBar({Key? key}) : preferredSize = const Size.fromHeight(56.0), super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: const MenuButtonLeading(),
      title: Text(curLl(context)!.screenTitle.home)
    );
  }
}

src/features/home/presentation/home_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../books/domain/book.dart';
import '../../profile/domain/profile.dart';

part 'home_screen_state.freezed.dart';

@freezed
class HomeScreenState with _$HomeScreenState {
  factory HomeScreenState({
    @Default([]) List<Book> books,
    @Default([]) List<Profile> authors
  }) = _HomeScreenState;
}


src/features/home/presentation/home_screen_controller.dart

import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'home_screen_state.dart';

part 'home_screen_controller.g.dart';

@Riverpod()
class HomeScreenController extends _$HomeScreenController {
  BookRepository get bookRepo => ref.watch(bookRepositoryProvider);
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);

  @override
  FutureOr<HomeScreenState> build() async {
    final books = await bookRepo.getPopularBooks(0, 10);
    // final authors = await profileRepo.getPopularAuthors(0, 10);
    return HomeScreenState(
      books: books,
      // authors: authors
    );
  }
}


src/features/home/presentation/home_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/common/widgets/see_all_header.dart';
import 'package:client/src/features/home/presentation/home_screen_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../common/constants/constants.dart';
import '../../../shared/constants.dart';
import '../../books/presentation/book_list/book_list_widget.dart';
import '../../localization/application/ll.dart';
import 'home_screen_app_bar.dart';

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ll = curLl(context);
    final cont = ref.watch(homeScreenControllerProvider.notifier);
    final state = ref.watch(homeScreenControllerProvider);

    return Scaffold(
      appBar: HomeScreenAppBar(),
      body: state.when(
        data: (state) => ListView(
          children: [
            Padding(
              padding: const EdgeInsets.all(p16),
              child: SeeAllHeader(
                labelText: 'Popular Books'.hardcoded,
                onSeeAll: () {
                  context.pushNamed(MyRoute.popularBooks.name);
                },
              ),
            ),
            BookListWidget(books: state.books),
            Padding(
              padding: const EdgeInsets.all(p16),
              child: SeeAllHeader(
                labelText: 'Popular Authors'.hardcoded,
                onSeeAll: () {
                  context.pushNamed(MyRoute.popularBooks.name);
                },
              ),
            ),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: IntrinsicHeight(
                child: Row(
                  children: [
                    for (final a in state.authors) Container(
                      height: 50, 
                      width: 50, 
                      color: Colors.red,
                      child: Text('some name')
                    ),
                  ]
                ),
              )
            ),
          ],
        ),
        error: defaultErrorHandler,
        loading: defaultLoading
      )
    );
  }
}


src/features/home/presentation/popular_books_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pagination/page_list_widget.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_item_widget.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_widget.dart';
import 'package:client/src/shared/pagination_list_callback_factory.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../books/domain/book.dart';

class PopularBooksScreen extends ConsumerWidget {
  PopularBooksScreen({super.key});

  PaginationItemsCallback<Book>? callback;
  RefreshController refreshController = RefreshController();
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    callback ??= PaginationCallbackFactory.instance
      .createPopularBooksCallback(ref);
    final cont = ref.watch(paginationListWidgetControllerProvider(callback!)
      .notifier);
    final state = ref.watch(paginationListWidgetControllerProvider(callback!));
    return Scaffold(
      appBar: AppBar(title: Text('Popular Books'.hardcoded)),
      body: state.when(
        data: (books) => PageListWidget(
          paginationController: cont,
          refreshController: refreshController,
          child: ListView.separated(
            padding: const EdgeInsets.all(p16),
            separatorBuilder: (_, __) => h16gap,
            itemCount: books.length,
            itemBuilder: (context, i) {
              return BookListItemWidget(listDirection: Axis.vertical, book: books[i] as Book);
            }
          )
        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      )
    );
  }
}




src/features/comments/application/comment_deleted_event.dart

import '../../../common/pub_sub.dart';

class CommentDeletedEvent extends PubSubEvent {
  final String commentId;

  CommentDeletedEvent(this.commentId);
}

src/features/comments/data/comment_repository.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:client/src/shared/dio.dart';
import 'package:client/src/shared/err.dart';
import 'package:dio/dio.dart';
import 'package:equatable/equatable.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../common/widgets/error_handler.dart';

part 'comment_repository.g.dart';

class CantEditCommentException extends AppException { }
class CannotAddCommentException extends AppException { }

class CommentsSorting {
  static const String nnew = 'new';
  static const String old = 'old';
  static const String popular = 'popular';
}

class CommentRepository {
  final Dio _dio;
  final String? _myId;

  CommentRepository({required Dio dio, String? myId}) 
    : _dio = dio, 
      _myId = myId;

  Future<List<Comment>> getComments(
    String subjectId, 
    {
      String sorting = CommentsSorting.nnew,
      String? questionId,
      int from = 0,
      int pageSize = 20
    }
  ) => err(() async {
    printWarning("$subjectId, $sorting, $questionId, $from, $pageSize");
    final resp = await _dio.get('comments', queryParameters: {
      'from': from,
      'pageSize': pageSize,
      'sorting': sorting,
      'subjectId': subjectId,
      'questionId': questionId
    });
    printWarning(resp.data);
    final comments = commentListFromJson(resp.data['data']);
    for (final co in comments) {
      printWarning("${co.content} myRate = ${co.myRate}");
    }
    return comments;
  });

  Future<Comment> addComment({ 
    required String content, 
    required String subjectId,
    required String subjectName,
    String? questionId
  }) => err(() async {
    try {
      if (content.isEmpty) throw "empty content";
      final resp = await _dio.post('comments', 
        queryParameters: {
          'subjectId': subjectId,
          'subjectName': subjectName,
          if (questionId != null)'questionId': questionId
        },
        data: {
          'content': content
        }
      );
      return Comment.fromJson(resp.data['data']);
    } on DioError catch (e) {
      if (e.type == DioErrorType.badResponse && 
          e.response?.data['error']['code'] == 'cannotAddComment') {
            throw CannotAddCommentException();
      }
      rethrow;
    }
  });

  Future<int> rate(String commentId, CommentRate rate) => err(() async {
    final resp = await _dio.post('comments/$commentId/rate', queryParameters: {
      'rate': rate == CommentRate.like ? 1 : -1
    });
    return resp.data['data'] as int;
  });

  Future<Comment> updateComment(String commentId, String newContent) => err(() async {
    try {
      final resp = await _dio.put('comments/$commentId', 
        data: { 'content': newContent }
      );
      // comment without answers.
      return Comment.fromJson(resp.data['data']);
    } on DioError catch (e) {
      if (e.response?.statusCode == 500 && e.response!.data['error']['code'] == 'cannotEditComment') {
        throw CantEditCommentException();
      }
      rethrow;
    }
  });

  Future<bool> deleteComment(String commentId) => err(() async {
    final resp = await _dio.delete('comments/$commentId');
    return resp.data['data'] as bool;
  });

  
}

@riverpod
CommentRepository commentRepository(CommentRepositoryRef ref) {
  return CommentRepository(dio: ref.watch(dioProvider), myId: ref.watch(myIdProvider));
}

src/features/comments/domain/comment_subject.dart

class CommentSubjects {
  static const String book = 'Book';
  static const String chapter = 'Chapter';

  List<String> get values => [book, chapter];
}

src/features/comments/domain/comment.dart

import 'package:client/src/common/log.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../../shared/identifiable.dart';
import '../../profile/domain/profile.dart';

part 'comment.freezed.dart';
part 'comment.g.dart';

enum CommentRate {
  @JsonValue(1) like,
  @JsonValue(-1) dislike
}

@freezed
class Comment with _$Comment, Identifiable {
  factory Comment({
    @JsonKey(name: "_id") @Default("") String id,
    required Profile author,
    @Default("") String content,
    @Default("") String subject,
    @Default("") String subjectName,
    @Default(0) int depth,
    @Default(0) int rate,

    @Default([]) List<Comment> answers,
    @Default(false) bool hasAnswers,

    CommentRate? myRate,

    required DateTime createdAt,
    required DateTime updatedAt
  }) = _Comment;

  factory Comment.fromJson(Map<String, dynamic> json) => _$CommentFromJson(json);
}

List<Comment> commentListFromJson(List<dynamic> list) {
  return list.map((c) => Comment.fromJson(c as Map<String, dynamic>)).toList();
}


src/features/comments/presentation/comments/comments_widget.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/comments/data/comment_repository.dart';
import 'package:client/src/features/comments/presentation/comments/comments_widget_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod/src/framework.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/log.dart';
import '../../../../common/utils/debounce.dart';
import '../comment/comment_widget.dart';
import 'comments_content_field_state.dart';


class CommentsWidget extends ConsumerWidget {
  CommentsWidget({
    super.key, 
    required this.subjectId, 
    required this.subjectName
  });

  final String subjectId;
  final String subjectName;
  final debouncer = Debouncer();
  final contentController = TextEditingController();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cont = ref.watch(commentsWidgetControllerProvider(subjectId, subjectName).notifier);
    final state = ref.watch(commentsWidgetControllerProvider(subjectId, subjectName));

    return state.when(
      data: (state) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: SegmentedButton<String>(
                selected: <String>{ state.sorting },
                onSelectionChanged: (selected) {
                  cont.sorting = selected.first;
                },
                showSelectedIcon: false,
                segments: [
                  ButtonSegment(
                    value: CommentsSorting.nnew,
                    label: Text("new".hardcoded)
                  ),
                  ButtonSegment(
                    value: CommentsSorting.old,
                    label: Text("old".hardcoded)
                  ),
                  ButtonSegment(
                    value: CommentsSorting.popular,
                    label: Text("popular".hardcoded)
                  ),
                ],
              ),
            ),
            h16gap,
            Consumer(
              builder: (context, ref, child) { 
                printInfo("return TextFormField(${ref.watch(commentsContentFieldState)})");
                final content = ref.watch(commentsContentFieldState);
                if (content.isEmpty) contentController.text = "";
                return ConstrainedBox(
                  constraints: const BoxConstraints(
                    maxHeight: 200
                  ),
                  child: TextFormField(
                    scrollPadding: EdgeInsets.zero,
                    controller: contentController,
                    onChanged: (v) {
                      debouncer.debounce(() => ref.watch(commentsContentFieldState.notifier).state = v);
                    },
                    maxLength: 1000,
                    maxLines: null,
                    decoration: InputDecoration(
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.send),
                        onPressed: () {
                          cont.addComment();
                        }
                      )
                    )
                  ),
                ); 
              },
            ),
            h8gap,
            ...state.comments.map((c) => CommentWidget(comment: c)).toList(),
            h8gap,
            TextButton(
              child: Text("Load More".hardcoded),
              onPressed: () {
                cont.addPage();
              }
            )
          ]
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: defaultErrorHandler
    );
  }
}

src/features/comments/presentation/comments/comments_widget_controller.dart

import 'package:client/src/common/mutable_list.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/comments/data/comment_repository.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:client/src/features/comments/presentation/comments/comments_content_field_state.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/shared/utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/pub_sub.dart';
import '../../application/comment_deleted_event.dart';
import 'comments_widget_state.dart';

part 'comments_widget_controller.g.dart';

@riverpod
class CommentsWidgetController extends _$CommentsWidgetController
    with PaginationController<Comment> {
  CommentRepository get commentRepo => ref.watch(commentRepositoryProvider);
  @override
  FutureOr<CommentsWidgetState> build(String subjectId, String subjectName) async {
    _listenDeletion();
    return CommentsWidgetState(comments: await getItems(0));
  }

  void _listenDeletion() {
    ref.listen(pubSub, (prev, next) {
      if (next is CommentDeletedEvent) {
        final comments = state.value!.comments.where((a) => a.id == next.commentId).toList();
        if (comments.isEmpty) return;
        state = AsyncData(state.value!.copyWith(
          comments: state.value!.comments.copyWithout(comments[0])
          )
        );
      }
    });
  }

  set sorting(String newSorting) {
    state = AsyncData(state.value!.copyWith(
      sorting: newSorting
    ));
    refresh();
  }

  Future<void> addComment() async {
    try {
      final Comment newComment = await commentRepo.addComment(
        content: ref.watch(commentsContentFieldState), 
        subjectId: subjectId,
        subjectName: subjectName,
      );
      ref.watch(commentsContentFieldState.notifier).state = "";
      state = AsyncData(
        state.value!.copyWith(
          comments: state.value!.comments.copyWith(newComment, start: true),
        ),
      );
    } on CannotAddCommentException catch (_) {
      Utils.showMessage(ref, ref.watch(currentLocalizationProvider).errors.cannotAddComment);
    }
  }
  
  @override
  set listState(List<Comment> newComments) => 
      state = AsyncData(state.value!.copyWith(comments: newComments));

  @override
  List<Comment> get listState => state.value!.comments;
  
  @override
  PaginationItemsCallback<Comment> get getItems => (int from) {
    return commentRepo.getComments(subjectId, 
      sorting: state.value?.sorting ?? CommentsSorting.nnew,
      from: from
    );
  };
}

src/features/comments/presentation/comments/comments_content_field_state.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

final commentsContentFieldState = StateProvider((ref) => "");

src/features/comments/presentation/comments/comments_widget_state.dart


import 'package:client/src/features/comments/data/comment_repository.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/comment.dart';

part 'comments_widget_state.freezed.dart';

@freezed
class CommentsWidgetState with _$CommentsWidgetState {
  factory CommentsWidgetState({
    @Default([]) List<Comment> comments,
    @Default(CommentsSorting.nnew) String sorting,
  }) = _CommentsWidgetState;
}

src/features/comments/presentation/comment/comment_widget_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/comment.dart';

part 'comment_widget_state.freezed.dart';

@freezed
class CommentWidgetState with _$CommentWidgetState {
  factory CommentWidgetState({
    required Comment comment,
    @Default(false) isFieldShown,
    @Default("") String fieldState,
    @Default(false) bool isEdit,
    @Default("") String editState
  }) = _CommentWidgetState; 
}

src/features/comments/presentation/comment/comment_widget.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:client/src/features/comments/presentation/comment/comment_widget_controller.dart';
import 'package:client/src/features/comments/presentation/comment/comment_widget_state.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';

import '../../../../common/utils/debounce.dart';
import '../../../reports/presentation/report/report_dialog.dart';

class CommentWidget extends ConsumerStatefulWidget {
  const CommentWidget({super.key, required this.comment});

  final Comment comment;

  @override
  _CommentWidgetState createState() => _CommentWidgetState();
}

class _CommentWidgetState extends ConsumerState<CommentWidget> {
  CommentWidgetController get cont =>
      ref.watch(commentWidgetControllerProvider(widget.comment).notifier);
  CommentWidgetState get state => 
      ref.watch(commentWidgetControllerProvider(widget.comment));

  final rateDebouncer = Debouncer(500);

  void onAnswerSubmit() async {
    await cont.submitAnswer();
  }

  void onAnswerFieldChange(String newContent) {
    cont.fieldState = newContent;
  }

  void onLoadMoreAnswers() async {
    await cont.loadAnswers();
  }

  void onHideAnswer() {
    cont.hideAnswerField();
  }

  void onShowAnswer() {
    cont.showAnswerField();
  }

  void onUpRate() async {
    rateDebouncer.debounce(() => cont.upRate());
  }

  void onDownRate() async {
    rateDebouncer.debounce(() => cont.downRate());
  }

  void onEdit() async {
    cont.toggleEdit();
  }

  void onEditFieldChanged(String v) {
    cont.editState = v;
  }

  void onHideEdit() async {
    cont.toggleEdit();
  }

  void onEditSubmit() async {
    cont.submitEdited();
  }

  void onReport() async {
    showReportDialog(context, state.comment);
  }

  void onDelete() async {
    cont.deleteThisComment();
  }

  final editingController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    final state = this.state;
    final comment = state.comment;
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        withDepth(
          comment.depth,
          child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Row(
                  children: [
                    CircleAvatar(
                      radius: 24,
                      backgroundImage:
                          NetworkImage(comment.author.avatarUrl ?? ""),
                    ),
                    w8gap,
                    Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(comment.author.displayName ?? comment.author.name,
                            style: Theme.of(context).textTheme.titleMedium,
                          ),
                          Text(Constants.dateFormat.format(comment.createdAt)),
                        ])
                  ]
                ),
                h8gap,
                if (state.isEdit)
                  TextFormField(
                    initialValue: comment.content,
                    onChanged: onEditFieldChanged,
                    maxLength: 1000,
                    decoration: InputDecoration(
                      suffixIcon: IconButton(
                        icon: Icon(state.editState.isEmpty 
                          ? Icons.close 
                          : Icons.check
                        ),
                        onPressed: () {
                          state.editState.isEmpty
                              ? onHideEdit()
                              : onEditSubmit();
                        },
                      ),
                    ),
                  )
                else
                  Text(comment.content),
                if (!state.isFieldShown)
                  Row(
                    children: [
                      w8gap,
                      if (!state.isEdit)
                        TextButton(
                          onPressed: onShowAnswer,
                          child: Text('answer'.hardcoded),
                        )
                      else 
                        TextButton(
                          onPressed: onHideEdit,
                          child: Text("hide".hardcoded)
                        ),

                      const Spacer(),
                      PopupMenuButton(
                        itemBuilder: (BuildContext context) => [
                          if (ref.watch(myIdProvider) == comment.author.id) ...[
                            PopupMenuItem(
                              onTap: onEdit,
                              child: Text('edit'.hardcoded),
                            ),
                            PopupMenuItem(
                              onTap: onDelete,
                              child: Text('delete'.hardcoded),
                            ),
                          ],
                          PopupMenuItem(
                            onTap: onReport,
                            child: Text('report'.hardcoded),
                          ),
                        ],
                      ),
                      InkWell(
                          onTap: onUpRate,
                          child: Icon(Icons.keyboard_arrow_up_rounded,
                              color: comment.myRate == CommentRate.like
                                  ? Colors.green
                                  : Theme.of(context).colorScheme.outline)),
                      w4gap,
                      ConstrainedBox(
                          constraints: const BoxConstraints(minWidth: p24),
                          child: Text(
                            comment.rate.toString(),
                            textAlign: TextAlign.center,
                          )),
                      w4gap,
                      InkWell(
                          onTap: onDownRate,
                          child: Icon(Icons.keyboard_arrow_down_rounded,
                            color: comment.myRate == CommentRate.dislike
                              ? Theme.of(context).colorScheme.error
                              : Theme.of(context).colorScheme.outline,
                          ),
                      ),
                    ]
                  ),
                if (state.comment.hasAnswers && state.comment.answers.isEmpty)
                  TextButton(
                    onPressed: onLoadMoreAnswers,
                    child: Text("Load More".hardcoded),
                  )
              ]),
        ),
        if (state.isFieldShown)
          Padding(
            padding: const EdgeInsets.only(bottom: p8, left: p8),
            child: TextFormField(
                initialValue: state.fieldState,
                onChanged: onAnswerFieldChange,
                decoration: InputDecoration(
                  suffixIcon: IconButton(
                  icon: state.fieldState.isEmpty
                      ? const Icon(Icons.close)
                      : const Icon(Icons.send),
                  onPressed: () {
                    state.fieldState.isEmpty
                        ? onHideAnswer()
                        : onAnswerSubmit();
                  },
                ),
              ),
            ),
          ),
        ...comment.answers.map((a) => CommentWidget(comment: a)).toList()
      ],
    );
  }

  Widget withDepth(int depth, {required Widget child}) {
    return IntrinsicHeight(
      child: Row(
        children: [
          for (int i = 0; i < depth; i++) ...[
            Padding(
              padding: const EdgeInsets.only(right: p16),
              child: Container(
                color: Theme.of(context).colorScheme.outline, 
                width: 2,
              ),
            ),
          ],
          Expanded(child: child),
        ]
      ),
    );
  }
}


src/features/comments/presentation/comment/comment_widget_controller.dart

import 'package:client/src/common/mutable_list.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:client/src/features/comments/presentation/comment/comment_widget_state.dart';
import 'package:client/src/shared/utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/log.dart';
import '../../../../common/pub_sub.dart';
import '../../application/comment_deleted_event.dart';
import '../../data/comment_repository.dart';

part 'comment_widget_controller.g.dart';

@riverpod
class CommentWidgetController extends _$CommentWidgetController {
  CommentRepository get commentRepo => ref.watch(commentRepositoryProvider);
  
  CommentWidgetState build(Comment comment) {
    _listenDeletion();
    return CommentWidgetState(comment: comment);
  }

  void _listenDeletion() {
    ref.listen(pubSub, (prev, next) {
      if (next is CommentDeletedEvent) {
        final comments = state.comment.answers.where((a) => a.id == next.commentId).toList();
        if (comments.isEmpty) return;
        state = state.copyWith(
          comment: state.comment.copyWith(
            answers: state.comment.answers.copyWithout(comments[0])
          )
        );
      }
    });
  }

  set fieldState(String f) => state = state.copyWith(fieldState: f);
  set editState(String e) => state = state.copyWith(editState: e);


  void showAnswerField() {
    state = state.copyWith(isFieldShown: true);
  }

  void hideAnswerField() {
    state = state.copyWith(fieldState: "", isFieldShown: false);
  }

  Future<void> upRate() async {
    int newRates = await commentRepo.rate(state.comment.id, CommentRate.like);
    printInfo(newRates);
    state = state.copyWith(
      comment: state.comment.copyWith(
        myRate: state.comment.myRate == CommentRate.like ? null : CommentRate.like,
        rate: newRates
      )
    );
  }

  Future<void> downRate() async {
    int newRates = await commentRepo.rate(state.comment.id, CommentRate.dislike);
    state = state.copyWith(
      comment: state.comment.copyWith(
        myRate: state.comment.myRate == CommentRate.dislike ? null : CommentRate.dislike,
        rate: newRates
      )
    );
  }

  Future<void> loadAnswers() async {
    final comments = await commentRepo.getComments(
      state.comment.subject,
      questionId: state.comment.id,
    );
    state = state.copyWith(
      comment: state.comment.copyWith(answers: comments)
    );
  }

  Future<void> submitAnswer() async {
    Comment newComment = await commentRepo.addComment(
      content: state.fieldState, 
      subjectId: state.comment.subject, 
      subjectName: state.comment.subjectName,
      questionId: state.comment.id
    );
    state = state.copyWith(
      comment: state.comment.copyWith(
        answers: state.comment.answers.copyWith(newComment),
      ),
    );
    hideAnswerField();
  } 

  Future<void> submitEdited() async {
    try {
      Comment updatedComment = await commentRepo.updateComment(
        state.comment.id, 
        state.editState
      );
      state = state.copyWith(
        comment: state.comment.copyWith(
          content: updatedComment.content,
          updatedAt: updatedComment.updatedAt,
        ),
        isEdit: false,
      );
    } on CantEditCommentException catch (_) {
      Utils.showMessage(ref, "Can't edit comment!");
    }
  }

  Future<void> toggleEdit() async {
    if (state.isEdit) {
      state = state.copyWith(isEdit: false, editState: "");
    } else {
      state = state.copyWith(isEdit: true);
    }
  }

  Future<void> deleteThisComment() async {
    bool deleted = await commentRepo.deleteComment(state.comment.id);
    if (deleted) {
      ref.watch(pubSub.notifier).push(CommentDeletedEvent(state.comment.id));
    }
  }
}

src/features/messages/application/from_chat_event.dart

import 'package:client/src/common/pub_sub.dart';

class FromChatEvent extends PubSubEvent { }

src/features/messages/data/chat_repository.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/common/socket_stream.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/messages/domain/message.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/dio.dart';
import 'package:client/src/shared/socket.dart';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ChatRepository {
  final Dio _dio;
  final String? _myId;

  ChatRepository(this._dio, this._myId);

  Future<List<Message>> getMessages(
    String otherId, 
    [
      int? from, 
      int? pageSize
    ]
  ) async {
    final resp = await _dio.get('chats/$otherId', queryParameters: {
      'from': from,
      'pageSize': pageSize
    }); 
    return messageListFromJson(resp.data['data']);
  }

  Future<List<Chat>> getChats([int? from, int? pageSize]) async {
    final resp = await _dio.get('chats', queryParameters: {
      'from': from,
      'pageSize': pageSize
    }); 
    return chatListFromJson(resp.data['data']);
  }

  Future<void> addMessage(String to, String content) async {
    _dio.post('chats', data: { 
      'from': _myId,
      'to': to,
      'content': content 
    });
  }

  Future<List<Chat>> getAdminChats([int? from, int? pageSize]) async {
    final resp = await _dio.get("reports/chats", queryParameters: {
      'from': from,
      'pageSize': pageSize
    });
    printInfo(resp.data);
    return List<dynamic>.from(resp.data[Str.dio.data]).map((c) {
      final chat = Chat.fromJson(c);
      return chat.copyWith(source: ChatSource.admin);
    }).toList();
    // return chatListFromJson(resp.data[Str.dio.data]);
  }

  Future<List<Message>> getAdminMessages(String reportId, [int? from, int? pageSize]) async {
    final resp = await _dio.get("reports/$reportId/messages", queryParameters: {
      'from': from,
      'pageSize': pageSize
    });
    return messageListFromJson(resp.data[Str.dio.data]);
  }

  Future<void> addAdminMessage(String reportId, String content) async {
    final resp = await _dio.post("reports/$reportId/messages", data: { 'content': content });
    // return Message.fromJson(resp.data);
  }
}


final chatRepositoryProvider = Provider(
  (ref) => ChatRepository(ref.watch(dioProvider), ref.watch(myIdProvider))
);

src/features/messages/domain/message.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message.freezed.dart';
part 'message.g.dart';

@freezed
class Message with _$Message {
  factory Message({
    @JsonKey(name: "_id") @Default("") String id,
    @Default("") String content,
    required Profile from,
    @Default("") String to,
    required DateTime createdAt,
    required DateTime updatedAt
  }) = _Message;

  factory Message.fromJson(Map<String, dynamic> json) => _$MessageFromJson(json);
}

messageListFromJson(List<dynamic> list) {
  return list.map((m) => Message.fromJson(m as Map<String, dynamic>))
    .toList();
}

src/features/messages/domain/chat.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../profile/domain/profile.dart';

part 'chat.freezed.dart';
part 'chat.g.dart';

enum ChatSource {
  admin, 
  user
}

@Freezed(toJson: false)
class Chat with _$Chat {
  factory Chat({
    @Default(ChatSource.user) ChatSource source,
    required Profile other,
    @Default("") String lastMessage,
  }) = _Chat;

  factory Chat.fromJson(Map<String, dynamic> json) => _$ChatFromJson(json);
}

chatListFromJson(List<dynamic> list) {
  return list.map((c) => Chat.fromJson(c as Map<String, dynamic>))
    .toList();
}

src/features/messages/presentation/chat/chat_screen.dart

import 'package:client/src/common/pagination/page_list_widget.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/messages/application/from_chat_event.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/messages/presentation/chats/chats_screen_controller.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/pub_sub.dart';
import '../../../../common/widgets/my_avatar.dart';
import '../../domain/message.dart';
import '../widgets/message_widget.dart';
import 'chat_screen_controller.dart';
import 'chat_screen_state.dart';

class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({
    super.key,
    required this.chat
  });

  final Chat chat;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ChatScreenState();
}
class _ChatScreenState extends ConsumerState<ChatScreen> {
  ChatScreenController get cont => 
      ref.watch(chatScreenControllerProvider(widget.chat).notifier);
  ChatScreenState get state => 
      ref.watch(chatScreenControllerProvider(widget.chat));

  final textCont = TextEditingController();
  final refreshController = RefreshController();

  @override
  Widget build(BuildContext context) {
    final state = this.state;
    final cont = this.cont;
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(
          onPressed: () {
            context.pop();
            ref.watch(pubSub.notifier).push(FromChatEvent());
          },
        ),
        title: Text(state.chat.other.displayName ?? state.chat.other.name),
        actions: [
          MyAvatar(url: state.chat.other.avatarUrl ?? "")
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: PageListWidget(
              paginationController: cont,
              refreshController: refreshController,
              child: ListView.builder(
                reverse: true,
                itemCount: state.messages.length,
                itemBuilder: (context, index) {
                  return MessageWidget(
                    isMy: (message) => ref.watch(myIdProvider) == message.from.id,
                    message: state.messages[index], 
                  );
                }
              )
            )
          ),
          Padding(
            padding: const EdgeInsets.all(p8),
            child: TextFormField(
              controller: textCont,
              decoration: InputDecoration(
                suffixIcon: IconButton(
                  icon: const Icon(Icons.send),
                  onPressed: () {
                    cont.send(textCont.text);
                    textCont.clear();
                  },
                )
              ),
            )
          )
        ]
      )
    );
  }

  // Widget buildMessage(Message message) { 
  //   bool my = ref.watch(myIdProvider) == message.from.id;
  //   return ListTile(
  //     leading: my ? null : MyAvatar(url: message.from.avatarUrl ?? ""),
  //     trailing: !my ? null : MyAvatar(url: message.from.avatarUrl ?? ""),
  //     title: Text(message.content),
  //     subtitle: Text("${my ? "me" : message.from.name} ${Constants.dateFormat.format(message.createdAt)}")
  //   );
  // }
}

src/features/messages/presentation/chat/chat_screen_controller.dart

import 'dart:async';

import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/messages/presentation/chat/chat_screen_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/pagination/pagination_controller.dart';
import '../../../../shared/socket.dart';
import '../../data/chat_repository.dart';
import '../../domain/message.dart';

part 'chat_screen_controller.g.dart';

@riverpod
class ChatScreenController extends _$ChatScreenController 
      with PaginationController<Message> {
  ChatRepository get chatRepo => ref.watch(chatRepositoryProvider);

  NextMessageHandler? nextMessageHandeler;

  @override
  ChatScreenState build(Chat chat) {
    printWarning("on ChatScreenController build");
    
    if (chat.source == ChatSource.admin) { 
      printSuccess("admin");
      nextMessageHandeler = NextMessageHandler(_onNextMessage, chat.other.id);
    } else if (chat.source == ChatSource.user) {
      printSuccess("user");
      nextMessageHandeler = NextMessageHandler(_onNextMessage);
    }

    ref.onDispose(() async {
      printWarning("on ChatScreenController dispose");
      await nextMessageHandeler?.dispose();
    });
    Future(refresh);
    return ChatScreenState(chat: chat);
  }

  /// adds next message
  void _onNextMessage(Message nextMessage) {
    // nextMessageHandler by default handles messages from any user to this user. 
    // here we filter them to only of this user or the other user. 
    // chat.other.id - reportId nextMessage.from.id
    // [state.chat.other.id, ref.watch(myIdProvider)].contains(nextMessage.from.id) 
    if (![ref.watch(myIdProvider), state.chat.other.id].contains(nextMessage.from.id)) return;
    printInfo("messageArrived");
    // if (![
    //   nextMessage.from.id, 
    //   ref.watch(myIdProvider),
    //   // nextMessage.to,
    //   ].contains(state.chat.other.id)) return;
    state = state.copyWith(
      messages: [nextMessage, ...state.messages]
    );
  }

  /*
  Chat {
    other: Profile {
      id
      name
    }
    lastMessage: string
  }
  messages: [
    Message {
      from: Profile {
        id
        name
      }
      to: string
      content: string

      createdAt: Date
      updatedAt: Date
    }
  ]
  когда слушаем сообщения из сокета то там нам приходят сообщения 
  от любого пользователя к этому пользователя и 
  от этого пользователя к любому пользователю

  в случае если это админский чат то будет
  от любого репорта к этому пользователю и 
  от этого пользователя к любому репорту

  from.id - reportId / myId
  to - reportId / myId
  */

  void send(String content) async {
    switch (state.chat.source) {
      case ChatSource.admin:
        await chatRepo.addAdminMessage(state.chat.other.id, content);
        break;
      case ChatSource.user:
        await chatRepo.addMessage(state.chat.other.id, content);
        break;
      default:
    }
  }
  
  @override
  List<Message> get listState => state.messages;

  @override
  set listState(List<Message> newMessages) => 
      state = state.copyWith(messages: newMessages);
  
  @override
  PaginationItemsCallback<Message> get getItems => (int from) {
    switch (state.chat.source) {
      case ChatSource.admin: return chatRepo.getAdminMessages(state.chat.other.id, from);
      case ChatSource.user: return chatRepo.getMessages(state.chat.other.id, from);
    }
  };
}

src/features/messages/presentation/chat/chat_screen_state.dart

import 'package:client/src/features/messages/domain/chat.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/message.dart';

part 'chat_screen_state.freezed.dart';

@freezed
class ChatScreenState with _$ChatScreenState {
  factory ChatScreenState({
    required Chat chat,
    @Default([]) List<Message> messages
  }) = _ChatScreenState;
}

src/features/messages/presentation/admin_chats/admin_chat_widget.dart

import 'package:client/src/features/messages/domain/chat.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AdminChatWidget extends ConsumerWidget {
  AdminChatWidget({super.key, required this.chat});

  Chat chat;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container();
  }
}

src/features/messages/presentation/chats/chat_widget.dart

import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/widgets/my_avatar.dart';

class ChatWidget extends ConsumerStatefulWidget {
  const ChatWidget({super.key, required this.chat, required this.onTap});

  final Chat chat;
  final VoidCallback onTap;

  @override
  _ChatWidgetState createState() => _ChatWidgetState();
}

class _ChatWidgetState extends ConsumerState<ChatWidget> {
  @override
  Widget build(BuildContext context) {
    return ListTile(
      onTap: widget.onTap,
      leading: MyAvatar(url: widget.chat.other.id),
      title: Text(widget.chat.other.displayName ?? widget.chat.other.name),
      subtitle: Text(widget.chat.lastMessage),
    );
  }
}

src/features/messages/presentation/chats/chats_screen_app_bar.dart

import 'package:client/src/features/localization/application/ll.dart';
import 'package:flutter/material.dart';

class ChatsScreenAppBar extends StatelessWidget with PreferredSizeWidget {
@override
  final Size preferredSize;

  ChatsScreenAppBar({Key? key}) : preferredSize = const Size.fromHeight(56.0), super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(curLl(context)!.screenTitle.messages)
    );
  }
}

src/features/messages/presentation/chats/chats_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/localization/application/current_locale.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/messages/data/chat_repository.dart';
import 'package:client/src/features/messages/presentation/chats/chats_screen_app_bar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/pagination/page_list_widget.dart';
import '../../../../shared/constants.dart';
import '../../domain/chat.dart';
import '../admin_chats/admin_chat_widget.dart';
import 'chat_widget.dart';
import 'chats_screen_controller.dart';
import 'chats_screen_state.dart';

class ChatsScreen extends ConsumerStatefulWidget {
  const ChatsScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ChatsScreenState();
}
class _ChatsScreenState extends ConsumerState<ChatsScreen> {
  ChatsScreenController get cont => ref.watch(chatsScreenControllerProvider.notifier);
  AsyncValue<ChatsScreenState> get state => ref.watch(chatsScreenControllerProvider);

  final refreshController = RefreshController();

  openChat(Chat chat) {
    context.pushNamed(MyRoute.chat.name, 
      params: {
        'id': chat.other.id,
      },
      extra: chat
    );
  }

  @override
  Widget build(BuildContext context) {
    return state.when(
      data: (state) {
        return Scaffold(
          appBar: ChatsScreenAppBar(),
          body: Column(
            children: [
              Expanded(
                child: PageListWidget(
                  paginationController: cont,
                  refreshController: refreshController, 
                  child: ListView.builder(
                    itemCount: state.chats.length,
                    itemBuilder: (context, index) {
                      return ChatWidget(
                        chat: state.chats[index], 
                        onTap: () => openChat(state.chats[index])
                      );
                    },
                  ),
                ),
              ),
              if (state.adminChats != null) ConstrainedBox(
                constraints: BoxConstraints(maxHeight: p200),
                child: Container(
                  child: SingleChildScrollView(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        for (int index = 0; index < state.adminChats!.length; index++) ChatWidget(
                          chat: state.adminChats![index],
                          // onTap: openChat(state.chats[index]),
                          onTap: () => openChat(state.adminChats![index])
                        )
                      ]
                    ),
                  ),
                )
              )
            ],
          ),
        );
      },
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}

src/features/messages/presentation/chats/chats_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/chat.dart';

part 'chats_screen_state.freezed.dart';

@freezed
class ChatsScreenState with _$ChatsScreenState {
  factory ChatsScreenState({
    required List<Chat> chats,
    List<Chat>? adminChats
  }) = _ChatsScreenState;
}

src/features/messages/presentation/chats/chats_screen_controller.dart


import 'dart:async';

import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/messages/data/chat_repository.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/messages/presentation/chats/chats_screen_state.dart';
import 'package:client/src/shared/socket.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:socket_io_client/socket_io_client.dart';

import '../../../../common/socket_stream.dart';
import '../../domain/message.dart';

part 'chats_screen_controller.g.dart';

@riverpod
class ChatsScreenController extends _$ChatsScreenController 
    with PaginationController<Chat>{
  ChatRepository get chatRepo => ref.watch(chatRepositoryProvider);

  NextMessageHandler? nextMessageHandeler;
  
  @override
  FutureOr<ChatsScreenState> build() async {
    printInfo('on ChatsScreenController build');
    nextMessageHandeler = NextMessageHandler(_onNextMessage);
    ref.onDispose(() async {
      printInfo("on ChatsScreenController dispose nextMessageHandeler = ($nextMessageHandeler)");
      await nextMessageHandeler?.dispose();
    });

    ref.onCancel(() {
      printInfo('on ChatsScreenController cancel');
    });
    ref.onResume(() {
      printInfo('on ChatsScreenController resume');
    });
    final chats = await getItems(0);
    Future(() => loadAdminChats());
    return ChatsScreenState(chats: chats);
  }

  Future<void> loadAdminChats() async {
    state = AsyncData(state.value!.copyWith(
      adminChats: await chatRepo.getAdminChats()
    ));
  }

  /// populates some chat
  void _onNextMessage(Message nextMessage) {
    Chat? chatToUpdate;

    try {
      chatToUpdate = state.value!.chats.firstWhere(
        (chat) => [nextMessage.from.id, nextMessage.to].contains(chat.other.id)
      );
    } catch (e) {
      return;
    }

    Chat newChat = chatToUpdate.copyWith(lastMessage: nextMessage.content);
    
    state = AsyncData(state.value!.copyWith(
      chats: List<Chat>.from(state.value!.chats)..replaceRange(
        state.value!.chats.indexOf(chatToUpdate),
        state.value!.chats.indexOf(chatToUpdate) + 1,
        [newChat]
      )
    ));
  }
  
  @override
  List<Chat> get listState => state.value!.chats;

  @override 
  set listState(List<Chat> newChats) => 
      state = AsyncData(state.value!.copyWith(chats: newChats));
  
  @override
  PaginationItemsCallback<Chat> get getItems => (int from) {
    return chatRepo.getChats(from);
  };
}

src/features/messages/presentation/widgets/message_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/widgets/my_avatar.dart';
import '../../../../shared/constants.dart';
import '../../domain/message.dart';

class MessageWidget extends ConsumerWidget {
  const MessageWidget({
    super.key,
    required this.isMy,
    required this.message
  });

  final Message message;
  final bool Function(Message message) isMy;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    bool my = isMy(message);
    return ListTile(
      leading: my ? null : MyAvatar(url: message.from.avatarUrl ?? ""),
      trailing: !my ? null : MyAvatar(url: message.from.avatarUrl ?? ""),
      title: Text(message.content),
      subtitle: Text("${my ? "me" : message.from.name} ${Constants.dateFormat.format(message.createdAt)}")
    );
  }
}


src/features/auth/application/my_id_provider.dart

import 'package:client/src/features/auth/application/current_user_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/auth_repository.dart';

final myIdProvider = Provider<String?>((ref) {
  final currentUser = ref.watch(currentUserProvider);
  return currentUser?.uid;
});

src/features/auth/application/current_user_provider.dart

import 'package:client/src/features/auth/data/auth_repository.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final currentUserStreamProvider = StreamProvider<User?>((ref) {
  return ref.watch(authRepositoryProvider).userChanges;
});

final currentUserProvider = Provider<User?>((ref) {
  final currentUser = ref.watch(currentUserStreamProvider);
  return currentUser.value;
});

src/features/auth/data/google_auth_repository.dart

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';

class GoogleAuthRepository { 
  /*
  paste this inside the <head></head> before deploying. 
  это нужно посмотреть в google cloud там credentials разные для web, android и ios. 
  <meta name="google-signin-client_id" 
    content="626801727731-some-credentials-for-the-web.apps.googleusercontent.com">
  */
  final _googleSignIn = GoogleSignIn(
    serverClientId: "626801727731-t82pausgvkhnb21siio50vnefhgg9806.apps.googleusercontent.com"
  );

  Future<UserCredential?> signIn() async {
    print("GoogleSignInProvider.login");
    if (kIsWeb) await FirebaseAuth.instance.setPersistence(Persistence.LOCAL);
    GoogleSignInAccount? googleUser = await _googleSignIn.signIn();

    if (googleUser == null) return null;

    final googleAuth = await googleUser.authentication;
    final credential = GoogleAuthProvider.credential(
      accessToken: googleAuth.accessToken,
      idToken: googleAuth.idToken
    );
    return await FirebaseAuth.instance.signInWithCredential(credential);
  }

  Future<GoogleSignInAccount?> selectGoogleAccount() async {
    if (kIsWeb) await FirebaseAuth.instance.setPersistence(Persistence.LOCAL);
    GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
    return googleUser;
  }

  Future<GoogleSignInAccount?> get currentUser => _googleSignIn.signInSilently();
  Future<bool> get isSignedIn => _googleSignIn.isSignedIn();

  Future<void> signOut() async {
    await _googleSignIn.disconnect();
    
  }
}

final googleAuthRepositoryProvider = Provider((ref) {
  return GoogleAuthRepository();
});

src/features/auth/data/auth_repository.dart

import 'dart:convert';

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/features/auth/data/google_auth_repository.dart';
import 'package:client/src/shared/err.dart';
import 'package:dio/dio.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';

import '../../../common/widgets/error_handler.dart';
import '../../../shared/dio.dart';
import '../../profile/domain/profile.dart';

class BlockedUserAuthException extends AppException { 
  static const String name = 'blockedUserAuth';
}

class AuthRepository {
  AuthRepository(GoogleAuthRepository googleAuth, Dio dio)
      : _googleAuth = googleAuth,
        _dio = dio {
    // FirebaseAuth.instance.userChanges().listen((u) {
    //   if (u == null) {
    //     print("Permanent User Listener: not authenticated");
    //     return;
    //   }
    //   print("User: $u");
    //   u.getIdTokenResult().then((r) {
    //     print("Token Result: $r");
    //     print("Claims: ${jsonEncode(r.claims)}");
    //   });
    // });
  }

  final Dio _dio;
  final GoogleAuthRepository _googleAuth;

  User? get currentUser => FirebaseAuth.instance.currentUser;
  Stream<User?> get userChanges => FirebaseAuth.instance.authStateChanges();

  Future<UserCredential> signInWithGoogle(GoogleSignInAccount acc) async {
    final auth = await acc.authentication;
    final creds = GoogleAuthProvider.credential(
        idToken: auth.idToken, accessToken: auth.accessToken);
    return await FirebaseAuth.instance.signInWithCredential(creds);
  }

  Future<UserCredential> signUpWithGoogle({
    required GoogleSignInAccount acc, 
    required Profile newProfile
  }) async {
    final auth = await acc.authentication;
    final resp = await _dio.post('auth/google',
        data: newProfile.toJson()
          ..addAll({
            "idToken".hardcoded: auth.idToken,
            "accessToken".hardcoded: auth.accessToken
          }));
    final creds = GoogleAuthProvider.credential(
        idToken: resp.data['data']['idToken'],
        accessToken: resp.data['data']['accessToken']);
    return await FirebaseAuth.instance.signInWithCredential(creds);
  }

  Future<UserCredential> signInWithEmailAndPassword(String email, String password) async {
    final creds = await FirebaseAuth.instance.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
    return creds;
  }

  Future<UserCredential> signUpWithEmailAndPassword({ // password
    required String email,
    required String password,
    required Profile newProfile
  }) async {
    final resp = await _dio.post('auth/password',
      data: newProfile.toJson()
        ..addAll({
          "email".hardcoded: email,
          "password".hardcoded: password
        })
    );
    return await FirebaseAuth.instance.signInWithCustomToken(resp.data['data']['customToken']);
  }

  Future<void> signOut() async {
    if (await _googleAuth.isSignedIn) {
      _googleAuth.signOut();
    }
    FirebaseAuth.instance.signOut();
  }

  Future<T> _handleBlockedAuth<T>(Future<T> Function() func) async {
    try {
      return await func();
    } on AppError catch (e) {
      if (e.code == BlockedUserAuthException.name) {
        throw BlockedUserAuthException();
      }
      rethrow;
    }
  }
}

final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepository(
    ref.watch(googleAuthRepositoryProvider), 
    ref.watch(dioProvider),
  );
});


src/features/auth/presentation/auth_screen_controller.dart

import 'package:client/src/features/auth/data/auth_repository.dart';
import 'package:client/src/features/auth/data/google_auth_repository.dart';
import 'package:client/src/features/auth/presentation/auth_screen_state.dart';
import 'package:client/src/features/books/application/local_bookmarks_provider.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/edit_profile_widget/edit_profile_widget_controller.dart';
import 'package:client/src/shared/utils.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../common/log.dart';
import '../../profile/application/currently_edited_profile.dart';

class AuthScreenController extends AutoDisposeNotifier<AuthScreenState> {
  @override
  AuthScreenState build() {
    _googleSignInRepo.currentUser.then((u) => state = state.copyWith(googleSignInAccount: u));
    return AuthScreenState();
  }

  GoogleAuthRepository get _googleSignInRepo => 
    ref.watch(googleAuthRepositoryProvider);

  void changeMode() {
    state = state.copyWith(
      mode: state.mode == AuthMode.signIn ? AuthMode.signUp : AuthMode.signIn);
  }

  set email(String m) => state = state.copyWith(email: m);
  set password(String p) => state = state.copyWith(password: p);
  set name(String n) => state = state.copyWith(name: n);
  set gender(Gender g) => state = state.copyWith(gender: g);
  set displayName(String dn) => state = state.copyWith(displayName: dn);
  set age(int a) => state = state.copyWith(age: a);

  String? passwordValidator(String? s) {
    printInfo("password validation");
    if ((s?.length ?? 0) < 6) {
      return ref.read(currentLocalizationProvider).errors.shortPassword;
    }
    return null;
  }

  Future<bool> submit() async {
    late UserCredential creds;
    if (state.isSignIn) {
      try {
        creds = await signIn();
      } on BlockedUserAuthException catch (_) {
        Utils.showMessage(ref, 'Account is blocked');
        return false;
      }
    } else if (state.isSignUp) {
      creds = await signUp();
    }
    if (creds.user == null) return false;
    await ref.watch(localBookmarksControllerProvider.notifier).syncBookmarks();
    return true;
  }

  Future<UserCredential> signUp() async {
    bool canSignUp = 
      ref.read(editProfileWidgetControllerProvider).isUniqueName;
    printInfo('canSignUp = $canSignUp');
    final authRepo = ref.watch(authRepositoryProvider);
    if (state.isGoogleAuth) {
      return await authRepo.signUpWithGoogle(
        acc: state.googleSignInAccount!,
        newProfile: ref.read(currentlyEditedProfileProvider)
      );
    } else {
      return await authRepo.signUpWithEmailAndPassword(
        email: state.email,
        password: state.password,
        newProfile: ref.read(currentlyEditedProfileProvider),
      );
    }
  }

  Future<UserCredential> signIn() async {
    try {
      final authRepo = ref.watch(authRepositoryProvider);
      if (state.isGoogleAuth) {
        return await authRepo.signInWithGoogle(state.googleSignInAccount!);
      } else {
        return await authRepo.signInWithEmailAndPassword(state.email, state.password);
      }
    } catch (_) {
      rethrow;
    }
  }

  void selectGoogleUser() async {
    state = state.copyWith(
      googleSignInAccount: 
        await _googleSignInRepo.selectGoogleAccount()
    );
    final auth = await state.googleSignInAccount!.authentication;
    final headers = await state.googleSignInAccount!.authHeaders;
    print("headers: $headers \n auth: ${auth.accessToken} ${auth.idToken}");
  }

  void backToEmailAndPassword() async {
    await ref.read(googleAuthRepositoryProvider).signOut();
    state = state.copyWith(googleSignInAccount: await _googleSignInRepo.currentUser);
  }

}

final authScreenControllerProvider = NotifierProvider.autoDispose<
  AuthScreenController,
  AuthScreenState
>(
  () => AuthScreenController(),
  dependencies: [
    googleAuthRepositoryProvider,
    authRepositoryProvider,
    currentlyEditedProfileProvider,
    editProfileWidgetControllerProvider,
    currentLocalizationProvider
  ]
);

src/features/auth/presentation/auth_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:google_sign_in/google_sign_in.dart';

import '../../profile/domain/profile.dart';

part 'auth_screen_state.freezed.dart';

enum AuthMode { signUp, signIn }

@freezed
class AuthScreenState with _$AuthScreenState {
  factory AuthScreenState({
    @Default(AuthMode.signIn) AuthMode mode,
    @Default("") String email,
    @Default("") String password, 
    @Default("") String name,
    @Default("") String displayName,
    @Default(0) int age,
    @Default(Gender.preferNotToSay) Gender gender,
    GoogleSignInAccount? googleSignInAccount,
    @Default(true) bool passwordTooLong
  }) = _AuthScreenState;
}

extension AuthScreenStateExtension on AuthScreenState {
  bool get isGoogleAuth => googleSignInAccount != null;
  bool get isSignIn => mode == AuthMode.signIn;
  bool get isSignUp => mode == AuthMode.signUp;
}

src/features/auth/presentation/auth_screen.dart

import 'package:client/src/common/build_context_ext.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/common/widgets/google_list_tile.dart';
import 'package:client/src/features/auth/presentation/auth_screen_controller.dart';
import 'package:client/src/features/auth/presentation/auth_screen_state.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/domain/localization.i69n.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';

import '../../../common/constants/constants.dart';
import '../../profile/presentation/edit_profile_widget/edit_profile_widget.dart';

class AuthScreen extends ConsumerStatefulWidget {
  const AuthScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _AuthScreenState();
}
class _AuthScreenState extends ConsumerState<AuthScreen> {
  AuthScreenController get cont => ref.watch(authScreenControllerProvider.notifier);

  void onSkip() {
    print("skip authentication");
    context.goNamed(MyRoute.home.name);
  }

  void onSignInSignUp() async {
    print("Sign in button clicked");
    final authenticated = await cont.submit();
    if (authenticated && context.mounted) {
      context.goNamed(MyRoute.home.name);
    }
  }

  void onChangeMode() {
    cont.changeMode();
  }

  final TextEditingController email = TextEditingController();
  final TextEditingController password = TextEditingController();
  final TextEditingController name = TextEditingController();
  final TextEditingController displayName = TextEditingController();
  final TextEditingController age = TextEditingController();
  Gender gender = Gender.preferNotToSay;

  final GlobalKey<FormState> formKey = GlobalKey<FormState>();

  @override
  Widget build(BuildContext context) {
    printInfo("AuthScreen build");
    final ll = ref.watch(currentLocalizationProvider);
    final state = ref.watch(authScreenControllerProvider);
    final c = cont;
    printInfo("PHOTO URL = ${state.googleSignInAccount?.photoUrl ?? "NO GOOGLE"}");
    formKey.currentState?.validate();

    if (context.isMobile) {
      return Scaffold(
        appBar: AppBar(
          title: Text(ll.screenTitle.authentication),
        ),
        body: ListView(
          padding: const EdgeInsets.all(p16),
          children: [
            buildContent(state, ll)
          ]
        ),
      );
    }
    
    return Scaffold(
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            maxWidth: p400
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(ll.screenTitle.authentication, 
                style: context.titleLarge, 
                textAlign: TextAlign.center,
              ),
              h16gap,
              buildContent(state, ll)
            ]
          ),
        ),
      )
    );
  }


  Widget buildContent(AuthScreenState state, Localization ll) {
    final c = cont;
    return Form(
      key: formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (state.googleSignInAccount == null) ...[
            TextField(
              controller: email,
              decoration: InputDecoration(
                labelText: ll.auth.email,
              ),
              onChanged: (v) {
                c.email = v;
              }
            ),
            h8gap,
            TextFormField(
              controller: password,
              decoration: InputDecoration(
                labelText: ll.auth.password,
              ),
              obscureText: true,
              onChanged: (newV) {
                c.password = newV;
              },
              autovalidateMode: AutovalidateMode.onUserInteraction,
              validator: c.passwordValidator
            ),
            h8gap,
            OutlinedButton.icon(
              icon: const Icon(FontAwesomeIcons.google, color: Colors.red),
              label: Text(ll.google),
              onPressed: () {
                c.selectGoogleUser();
              }
            ),
            h8gap
          ] 
          else GoogleListTile(
            googleSignInAccount: state.googleSignInAccount, 
            onRemove: () {
              print("back to email + password");
              c.backToEmailAndPassword();
            }
          ),
          if (state.isSignUp) ...[
            const Divider(),
            h8gap,
            const EditProfileWidget(isAuth: true),
          ],
          const Divider(),
          Row(
            children: [
              // skip
              Expanded(
                child: OutlinedButton(
                  onPressed: onSkip,
                  child: Text(ll.auth.skip),
                ),
              ),
              w16gap,
          
              // sign in with email and password
              Expanded(
                child: FilledButton(
                  onPressed: onSignInSignUp,
                  child: Text(state.isSignUp 
                    ? ll.auth.signUp 
                    : ll.auth.signIn,
                  ),
                ),
              ),
            ]
          ),
      
          h16gap,
          TextButton(
            onPressed: onChangeMode,
            child: Text(ll.auth.switchTo(state.isSignIn 
              ? ll.auth.signUp 
              : ll.auth.signIn)
            ),
          )
        ]
      ),
    );
  }
}


src/features/chapters/application/events.dart

import 'package:client/src/common/pub_sub.dart';

import '../domain/chapter.dart';

class ChaptersEditedEvent extends PubSubEvent { }


class ChapterUpdatedEvent extends ChaptersEditedEvent {
  final Chapter? chapter;

  ChapterUpdatedEvent([this.chapter]);
}


class ChapterAddedEvent extends ChaptersEditedEvent {
  final Chapter? chapter;

  ChapterAddedEvent([this.chapter]);
}


class ChapterDeletedEvent extends ChaptersEditedEvent { 
  final String chapterId;

  ChapterDeletedEvent(this.chapterId);
}

src/features/chapters/data/chapter_repository.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/shared/constants.dart';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../shared/dio.dart';

class ChapterNav {
  String? next;
  String? previous;

  ChapterNav(this.next, this.previous);

  factory ChapterNav.fromJson(Map<String, dynamic> json) {
    return ChapterNav(json['next'], json['previous']);
  }
}

class ChapterRepository {
  final Dio _dio;
  final String? _myId;

  ChapterRepository(this._dio, this._myId);

  Future<List<Chapter>> getChapters(
    String bookId, 
    [
      int from = 0, 
      int pageSize = 20
    ]
  ) async {
    final resp = await _dio.get(Str.dio.chapters, queryParameters: {
      Str.dio.bookId: bookId,
      Str.dio.from: from,
      Str.dio.pageSize: pageSize
    });
    return chapterListFromJson(resp.data[Str.dio.data]);
  }

  Future<ChapterNav> getNavigation(String chapterId) async {
    final resp = await _dio.get(Str.dio.chapterNav(chapterId));
    printInfo(resp);
    final nav = ChapterNav.fromJson(resp.data[Str.dio.data]);
    printInfo("next=${nav.next} previous=${nav.previous}");
    return nav;
  }

  Future<Chapter> getChapter(String chapterId) async {
    final resp = await _dio.get(Str.dio.chapter(chapterId));
    final chapter = Chapter.fromJson(resp.data[Str.dio.data]);
    return chapter;
  }

  Future<bool> deleteChapter(String chapterId) async {
    final resp = await _dio.delete(Str.dio.chapter(chapterId));
    return resp.data[Str.dio.data] as bool;
  }

  Future<Chapter> updateChapter(Chapter newChapter) async {
    printWarning(newChapter.toJson());
    final resp = await _dio.put(Str.dio.chapter(newChapter.id), data: newChapter.toJson());
    final chapter = Chapter.fromJson(resp.data[Str.dio.data]);
    return chapter;
  }
  
  Future<Chapter> addChapter(Chapter newChapter) async {
    final resp = await _dio.post(Str.dio.chapters, data: newChapter.toJson());
    final createdChapter = Chapter.fromJson(resp.data[Str.dio.data]);
    return createdChapter;
  }

  Future<ReadingsState> toggleState(String chapterId) async {
    final resp = await _dio.post(Str.dio.chapterState(chapterId));
    return readingsStateFromString(resp.data[Str.dio.data]);
  }
}

final chapterRepositoryProvider = Provider((ref) {
  return ChapterRepository(ref.watch(dioProvider), ref.watch(myIdProvider));
});

src/features/chapters/domain/chapter.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../../common/ignore.dart';
import '../../comments/domain/comment.dart';

part 'chapter.freezed.dart';
part 'chapter.g.dart';

@freezed
class Chapter with _$Chapter {
  factory Chapter({
    @JsonKey(name: "_id") @Default("") String id,
    @Default("") String name,
    @Default("") String content,
    @Default(ReadingsState.unpublished) ReadingsState state,
    // @JsonKey(name: 'book') required String bookId,
    required Book book,
    @JsonKey(toJson: ignore, includeIfNull: false) List<Comment>? comments,

    DateTime? createdAt,
    DateTime? updatedAt
  }) = _Chapter;

  factory Chapter.fromJson(Map<String, dynamic> json) => _$ChapterFromJson(json);
}

chapterListFromJson(List<dynamic> list) {
  return list.map((c) => Chapter.fromJson(c as Map<String, dynamic>))
    .toList();
}

extension ChapterStateExtension on Chapter {
  bool get isPublished => state == ReadingsState.published;
  bool get isUnpublished => state == ReadingsState.unpublished;
}

extension ChapterLifecycleExtension on Chapter { 
  bool exists() => id.isNotEmpty;
}

src/features/chapters/presentation/chapters/book_chapters_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/common/pagination/simple_pagination_list_screen.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/chapters/application/events.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/shared/pagination_list_callback_factory.dart';
import 'package:flutter/material.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/pagination/page_list_widget.dart';
import '../../../../common/pub_sub.dart';
import '../../../../shared/constants.dart';
import '../chapter/chapter_widget.dart';
import 'book_chapters_screen_controller.dart';

class BookChaptersScreen extends ConsumerStatefulWidget {
  const BookChaptersScreen({super.key, required this.bookId, required this.book});

  final Book book;
  final String bookId;

  @override
  _BookChaptersScreenState createState() => _BookChaptersScreenState();
}

class _BookChaptersScreenState extends ConsumerState<BookChaptersScreen> {
  BookChaptersScreenController get cont => 
      ref.watch(bookChaptersScreenControllerProvider(widget.bookId).notifier);
  AsyncValue<List<Chapter>> get state => 
      ref.watch(bookChaptersScreenControllerProvider(widget.bookId));

  final refreshController = RefreshController();

  void onAddChapter() {
    context.pushNamed(MyRoute.addChapter.name, 
      params: {
        'id': widget.bookId
      },
      extra: widget.book
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = this.state;
    final cont = this.cont;
    ref.listen(pubSub, (prev, next) { 
      if (next is ChaptersEditedEvent) cont.handleEdited(next);
    });
    return state.when(
      data: (chapters) => Scaffold(
        appBar: AppBar(
          title: Text('Chapters'.hardcoded),
        ),
        body: PageListWidget(
          refreshController: refreshController,
          paginationController: cont,
          child: ListView.builder(
            itemCount: chapters.length,
            itemBuilder: (context, i) {
              return ChapterWidget(chapter: chapters[i]);
            },
          )
        ),
        floatingActionButton: cont.isMy ? FloatingActionButton.extended(
          label: Text("Add Chapter".hardcoded),
          icon: const Icon(Icons.add),
          onPressed: onAddChapter,
        ) : null,
      ),
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}

src/features/chapters/presentation/chapters/book_chapters_screen_controller.dart

import 'package:client/src/common/mutable_list.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/chapters/application/events.dart';
import 'package:client/src/features/chapters/data/chapter_repository.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/shared/pagination_list_callback_factory.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../auth/application/my_id_provider.dart';
import '../../../books/presentation/book/book_screen_controller.dart';

part 'book_chapters_screen_controller.g.dart';

@riverpod
class BookChaptersScreenController extends _$BookChaptersScreenController
    with PaginationController<Chapter> {
  ChapterRepository get chapterRepo => ref.watch(chapterRepositoryProvider);

  @override
  FutureOr<List<Chapter>> build(String bookId) async {
    final chapters = await getItems(0);
    return chapters;
  }

  void handleEdited(ChaptersEditedEvent event) {
    if (event is ChapterAddedEvent && event.chapter != null) {
      state = AsyncData(state.value!.copyWith(event.chapter!, start: true));
    } else if (event is ChapterUpdatedEvent && event.chapter != null) {
      state = AsyncData(state.value!.withReplacement(
          event.chapter!, (ch) => ch.id == event.chapter!.id));
    }
  }


  bool get isMy => ref.watch( // TODO: duplicate (chapter_screen_controller.dart)
    bookScreenControllerProvider(bookId)
        .select((b) => b.value!.book.author.id)) == ref.watch(myIdProvider);
  
  @override
  List<Chapter> get listState => state.value!;

  @override
  set listState(List<Chapter> newChapters) => state = AsyncData(newChapters);
  
  @override
  PaginationItemsCallback<Chapter> get getItems => (int from) {
    return chapterRepo.getChapters(bookId, from);
  };
}

src/features/chapters/presentation/chapter/chapter_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/chapter.dart';

part 'chapter_screen_state.freezed.dart';

@freezed
class ChapterScreenState with _$ChapterScreenState {
  factory ChapterScreenState({
    required Chapter chapter,
    String? next,
    String? previous
  }) = _ChapterScreenState;
}

src/features/chapters/presentation/chapter/chapter_screen_controller.dart

import 'package:client/src/features/chapters/data/chapter_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../auth/application/my_id_provider.dart';
import '../../../books/presentation/book/book_screen_controller.dart';
import '../../domain/chapter.dart';
import 'chapter_screen_state.dart';

part 'chapter_screen_controller.g.dart';

@riverpod
class ChapterScreenController extends _$ChapterScreenController {
  ChapterRepository get chapterRepo => ref.watch(chapterRepositoryProvider);
  
  @override
  FutureOr<ChapterScreenState> build(String chapterId) async {
    final chapter = await chapterRepo.getChapter(chapterId);
    final state = ChapterScreenState(chapter: chapter);
    if (chapter.isUnpublished) return state;
    final nav = await chapterRepo.getNavigation(chapterId);
    return state.copyWith(
      next: nav.next,
      previous: nav.previous
    );
  }

  void refresh() async {
    state = AsyncData(state.value!.copyWith(
      chapter: await chapterRepo.getChapter(chapterId)
    ));
  }
  
  bool get isMy => ref.watch( // TODO: duplicate (book_chapters_screen_controller.dart)
    bookScreenControllerProvider(state.value!.chapter.book.id)
        .select((b) => b.value!.book.author.id)) == ref.watch(myIdProvider);

  void setChapter(Chapter chapter) {
    state = AsyncData(state.value!.copyWith(chapter: chapter));
  }
}

src/features/chapters/presentation/chapter/chapter_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/presentation/book/book_screen_controller.dart';
import 'package:client/src/features/books/presentation/widgets/readings_state_widget.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/features/chapters/presentation/chapter/chapter_screen_controller.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/domain/localization.i69n.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/constants/constants.dart';
import '../../../books/domain/book.dart';
import '../../../comments/domain/comment_subject.dart';
import '../../../comments/presentation/comments/comments_widget.dart';
import '../../application/events.dart';
import 'chapter_screen_state.dart';

class ChapterScreen extends ConsumerStatefulWidget {
  const ChapterScreen({super.key, required this.chapterId});

  final String chapterId;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ChapterScreenState();
}
class _ChapterScreenState extends ConsumerState<ChapterScreen> {
  ChapterScreenController get cont => ref.watch(chapterScreenControllerProvider(widget.chapterId).notifier);
  AsyncValue<ChapterScreenState> get state => ref.watch(chapterScreenControllerProvider(widget.chapterId));
  Localization get ll => ref.watch(currentLocalizationProvider);

  void onEdit() {
    printWarning('onEditChapter');
    context.pushNamed(MyRoute.editChapter.name, 
      params: {
        'id': widget.chapterId
      },
      extra: state.value!.chapter
    );
  }

  void onPrevious() {
    printInfo(state.value!.previous);
    if (state.value!.previous != null) {
      context.pushReplacementNamed(MyRoute.chapter.name, 
        params: {
          "id": state.value!.previous!
        }
      );
    } else {
      Utils.showMessagew(ref, ll.chapter.firstChapterWarning);      
    }
  }

  void onNext() {
    if (state.value!.next != null) {
      context.pushReplacementNamed(MyRoute.chapter.name, 
        params: {
          "id": state.value!.next!
        }
      );
    } else {
      Utils.showMessagew(ref, ll.chapter.lastChapterWarning);
    }
  }


  @override
  Widget build(BuildContext context) {
    ref.listen(pubSub, (prev, next) {
      if (next is ChapterUpdatedEvent) {
        cont.refresh();
      }
    });
    final state = this.state;
    return state.when(
      data: (state) => Scaffold(
        // floatingActionButton: cont.isMy
        //   ? FloatingActionButton(
        //     onPressed: onEdit,
        //     child: const Icon(Icons.edit),
        //   ) 
        //   : null,
        body: SafeArea(
          child: ListView(
            padding: const EdgeInsets.symmetric(horizontal: p8),
            children: [
              AppBar(
                title: Text(state.chapter.name),
                actions: [
                  if (cont.isMy) IconButton(
                    icon: const Icon(Icons.edit),
                    onPressed: onEdit,
                  )
                ]
              ),
              Padding(
                padding: const EdgeInsets.all(p8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (cont.isMy) 
                      ReadingsStateWidget(state: state.chapter.state),
                    Text(state.chapter.name, 
                      style: Theme.of(context).textTheme.headlineMedium
                    ),
                    h8gap,
                    Text(state.chapter.content, 
                      style: Theme.of(context).textTheme.bodyLarge
                    )
                  ]
                ),
              ),
              if (state.chapter.isPublished) Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: onPrevious,
                      child: Text("Previous".hardcoded),
                    ),
                  ),
                  w16gap,
                  Expanded(
                    child: FilledButton(
                      onPressed: onNext,
                      child: Text("Next".hardcoded),
                    ),
                  )
                ]
              ),
              h8gap,
              CommentsWidget(
                subjectId: state.chapter.id,
                subjectName: CommentSubjects.chapter
              )
            ]
          ),
        )
      ),
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}

src/features/chapters/presentation/chapter/chapter_widget.dart

import 'package:client/src/features/books/presentation/widgets/readings_state_widget.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

class ChapterWidget extends ConsumerStatefulWidget {
  const ChapterWidget({super.key, required this.chapter});

  final Chapter chapter;

  @override
  _ChapterWidgetState createState() => _ChapterWidgetState();
}

class _ChapterWidgetState extends ConsumerState<ChapterWidget> {
  @override
  Widget build(BuildContext context) {
    return ListTile(
      onTap: () {
        context.pushNamed(MyRoute.chapter.name, params: {
          'id': widget.chapter.id
        });
      },
      title: Text(widget.chapter.name),
      subtitle: Row(
        children: [
          Text(Constants.dateFormat.format(widget.chapter.createdAt!)),
          const Spacer(),
          ReadingsStateWidget(state: widget.chapter.state),
        ],
      )
    );
  }
}

src/features/chapters/presentation/edit_chapter/edit_chapter_screen_controller.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/chapters/data/chapter_repository.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:client/src/shared/utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/pub_sub.dart';
import 'edit_chapter_screen_state.dart';

part 'edit_chapter_screen_controller.g.dart';

@riverpod
class EditChapterScreenController extends _$EditChapterScreenController {
  ChapterRepository get chapterRepo => ref.watch(chapterRepositoryProvider);

  EditChapterScreenState build(Chapter chapterToEdit) {
    return EditChapterScreenState(chapter: chapterToEdit);
  }

  Future<ReadingsState?> toggleState() async {
    try {
      final newReadingsState = await chapterRepo.toggleState(state.chapter.id);
      printSuccess(newReadingsState);
      state = state.copyWith(chapter: state.chapter.copyWith(state: newReadingsState));
      return newReadingsState;
    } catch (e) {
      return null;
    }
  }

  set content(String n) =>
      state = state.copyWith(chapter: state.chapter.copyWith(content: n));
  set name(String n) =>
      state = state.copyWith(chapter: state.chapter.copyWith(name: n));

  Future<Chapter> save() async {
    Chapter chapter = state.chapter.exists()
      ? await chapterRepo.updateChapter(state.chapter)
      : await chapterRepo.addChapter(state.chapter); 
    return chapter;
  }

  Future<void> deleteThisChapter() async {
    await chapterRepo.deleteChapter(state.chapter.id);
  }
}

src/features/chapters/presentation/edit_chapter/edit_chapter_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/features/books/presentation/widgets/readings_state_widget.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:client/src/shared/utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/pub_sub.dart';
import '../../../../common/utils/debounce.dart';
import '../../../books/domain/book.dart';
import '../../application/events.dart';
import 'edit_chapter_screen_controller.dart';
import 'edit_chapter_screen_state.dart';

class EditChapterScreen extends ConsumerStatefulWidget {
  const EditChapterScreen({super.key, required this.chapter});

  factory EditChapterScreen.add({
    Key? key, 
    required Book forBook
  }) => 
    EditChapterScreen(key: key, chapter: Chapter(book: forBook));

  final Chapter chapter;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _EditChapterScreenState();
}
class _EditChapterScreenState extends ConsumerState<EditChapterScreen> {
  EditChapterScreenController get cont => 
      ref.watch(editChapterScreenControllerProvider(widget.chapter).notifier);
  EditChapterScreenState get state => 
      ref.watch(editChapterScreenControllerProvider(widget.chapter));

  final debouncer = Debouncer();

  @override
  void dispose() {
    debouncer.dispose();
    super.dispose();
  }

  void onToggleState() {
    cont.toggleState().then((newState) {
      if (!context.mounted) return;
      if (newState == null) {
        showDialog(
          context: context, 
          builder: (context) {
            return AlertDialog(title: Text("Was not able to ${state.chapter.isPublished ? 'publish' : 'unpublish'}."));
          }
        );
      } else {
        ref.watch(pubSub.notifier).push(ChapterUpdatedEvent(state.chapter));
        printInfo(newState);
        Utils.showMessagew(ref, "${state.chapter.isPublished ? 'Published' : 'Unpublished'} successfully.");
      }
    });
  }

  Future<void> onChangeName(String newName) async {
    debouncer.debounce(() => cont.name = newName);
  }

  Future<void> onChangeContent(String newContent) async {
    debouncer.debounce(() => cont.content = newContent);
  }

  Future<void> onSave() async {
    try {
      final existed = state.chapter.exists();
      final chapter = await cont.save();
      if (context.mounted) {
        ref.watch(pubSub.notifier).push(existed 
          ? ChapterUpdatedEvent(chapter) 
          : ChapterAddedEvent(chapter));
        context.pop();
      }
    } catch (e) {
      printError(e);
      Utils.showMessagew(ref, "Error saving chapter".hardcoded);
    }
  }

  Future<void> onDeleteThisChapter() async {
    try {
      await cont.deleteThisChapter();
      ref.watch(pubSub.notifier).push(ChapterDeletedEvent(widget.chapter.id));
      if (context.mounted) {
        context.pop();
        context.pop();
      }
    } catch (e) {
      Utils.showMessagew(ref, "Error deleting chapter".hardcoded);
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = this.state;
    return Scaffold(
      appBar: AppBar(
        title: Text('Edit Chapter'.hardcoded),
        actions: [
          if (state.chapter.exists()) PopupMenuButton(
            itemBuilder: (context) {
              return [
                PopupMenuItem(
                  onTap: onToggleState,
                  child: state.chapter.isPublished 
                    ? Text('unpublish'.hardcoded)
                    : Text('publish'.hardcoded),
                ),
                PopupMenuItem(
                  onTap: onDeleteThisChapter,
                  child: Text("delete chapter".hardcoded)
                )
              ];
            },
          )
        ]
      ),
      body: Padding(
        padding: const EdgeInsets.all(p8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            ReadingsStateWidget(state: state.chapter.state),
            TextFormField(
              initialValue: state.chapter.name,
              onChanged: onChangeName,
              decoration: InputDecoration(
                border: InputBorder.none,
                hintText: 'Chapter Name'.hardcoded,
              ),
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            Expanded(
              child: TextFormField(
              initialValue: state.chapter.content,
                onChanged: onChangeContent,
                maxLines: null,
                maxLength: 10000,
                decoration: InputDecoration(
                  border: InputBorder.none,
                ),
              ),
            ),
          ]
        ),
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(p8),
        child: FilledButton.icon(
          icon: const Icon(Icons.check),
          label: Text("save".hardcoded),
          onPressed: onSave,
        ),
      ),
    );
  }
}

src/features/chapters/presentation/edit_chapter/edit_chapter_screen_state.dart

import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'edit_chapter_screen_state.freezed.dart';

@freezed
class EditChapterScreenState with _$EditChapterScreenState {
  factory EditChapterScreenState({
    required Chapter chapter
  }) = _EditChapterScreenState;
}

src/features/books/application/books_changed_event.dart

import 'package:client/src/common/pub_sub.dart';

import '../domain/book.dart';


class BooksChangedEvent extends PubSubEvent {}


class BookEditedEvent extends BooksChangedEvent {
  final Book updatedBook;

  BookEditedEvent(this.updatedBook);
}


class BookDeletedEvent extends BooksChangedEvent { }


class BookAddedEvent extends BooksChangedEvent { }

src/features/books/application/local_bookmarks_provider.dart

import 'package:client/src/features/books/data/local_book_repository.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../common/log.dart';

part 'local_bookmarks_provider.g.dart';

final bookmarksStreamProvider = StreamProvider<List<String>>(
  (ref) => ref.watch(localBookRepositoryProvider).watchBookmarks(),
  dependencies: [
    localBookRepositoryProvider // because it will be overwriten
  ]
);

@Riverpod(keepAlive: true)
class LocalBookmarksController extends _$LocalBookmarksController {
  @override
  List<String> build() {
    final value = ref.watch(bookmarksStreamProvider).value;
    printSuccess("LocalBookmarksController built $value");
    return ref.watch(bookmarksStreamProvider).value ?? [];
  }

  bool isBookmarked(String bookId) {
    return state.contains(bookId);
  }

  Future<void> syncBookmarks() async {
    try {
      await ref.watch(profileRepositoryProvider).saveBookmarks(state);
      await ref.watch(localBookRepositoryProvider).deleteBookmarks();
    } catch (e) {
      rethrow;
    }
  }
}

src/features/books/data/book_repository.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/data/local_book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/domain/filtering_source.dart';
import 'package:client/src/features/books/domain/filters.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/dio.dart';
import 'package:dio/dio.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../common/widgets/error_handler.dart';
import '../../../shared/err.dart';

part 'book_repository.g.dart';

class StateChangeNotPermitted extends AppException { }

class BookRepository {
  final Dio _dio;
  final String? myId;
  final LocalBookRepository local;

  BookRepository({required Dio dio, required this.myId, required this.local})
      : _dio = dio;

  Future<Book> getBook(String id) async {
    final resp = await _dio.get('books/$id');
    final book = Book.fromJson(resp.data['data']);
    printSuccess(book);
    return book;
  }

  Future<Book> updateBook(Book book) async {
    printWarning(book);
    final resp = await _dio.patch('books/${book.id}',
      data: book.toJson()
    );
    printSuccess(resp.data['data']);
    return Book.fromJson(resp.data['data']);
  }

  Future<Book> addBook(Book book) async {
    final resp = await _dio.post('books', data: book.toJson());
    final addedBook = Book.fromJson(resp.data['data']);
    return addedBook;
  }

  Future<List<Book>> getBooks([
    Filters? filters,
    int from = 0,
    int pageSize = 20
  ]) async {
    return await err(() async {
      final resp = await _dio.get('books', 
        queryParameters: filters?.toJson()
          ?..addAll({
            'from': from, 
            'pageSize': pageSize 
          })
      );
      printInfo(resp.data['data'].map((b) => { 'id': b['_id'], 'name': b['name'], 'bookmarked': b['bookmarked']}).toList());
      return bookListFromJson(resp.data['data']);
    });
  }

  Future<List<Book>> getPopularBooks([int from = 0, int pageSize = 20]) async {
    return await err(() async {
      final resp = await _dio.get(Str.dio.popularBooks,
        queryParameters: {
          Str.dio.from: from,
          Str.dio.pageSize: pageSize
        }
      );
      printSuccess(resp.data);
      return bookListFromJson(resp.data[Str.dio.data]);
    });
  }

  Future<bool> deleteBook(String id) async {
    final resp = await _dio.delete('books/$id');
    final result = resp.data['data'] as bool;
    return result;
  }

  Future<FilteringSource> getFilteringSource() async {
    final resp = await _dio.get("books/filtering-source");
    final source = FilteringSource.fromJson(resp.data['data']);
    return source;
  }

  Future<ReadingsState> changeState(String bookId) => err(() async {
    try {
      final resp = await _dio.post("books/$bookId/state");
      return readingsStateFromString(resp.data['data']);
    } on DioError catch (e) {
      if (e.type == DioErrorType.badResponse && 
        e.response?.data['error']['code'] == 'cannotChangeState'){ 
          throw StateChangeNotPermitted();
      }
      rethrow;
    }
  });

  Future<bool> toggleLike(String bookId) async {
    final resp = await _dio.post("books/$bookId/like");
    return resp.data['data'] as bool;
  }

  Future<bool> toggleBookmark(String bookId) async {
    if (myId != null) {
      final resp = await _dio.post("books/$bookId/bookmark");
      return resp.data['data'] as bool;
    }
    await local.toggleBookmark(bookId);
    return true;
  }
}

@Riverpod(keepAlive: true)
BookRepository bookRepository(BookRepositoryRef ref) {
  return BookRepository(
    dio: ref.watch(dioProvider),
    myId: ref.watch(myIdProvider),
    local: ref.watch(localBookRepositoryProvider)
  );
}


src/features/books/data/sembast_book_repository.dart


import 'dart:convert';

import 'package:client/src/common/log.dart';
import 'package:client/src/features/books/data/local_book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/shared/utils.dart';
import 'package:path_provider/path_provider.dart';
import 'package:sembast/sembast.dart';
import 'package:sembast/sembast_io.dart';
import 'package:sembast/src/json_encodable_codec.dart';


class SembastBookRepsoitory implements LocalBookRepository {
  SembastBookRepsoitory(this.db);

  final Database db;
  final storea = StoreRef<int, String>('bookmarks');
  final store = StoreRef.main();

  // static Future<SembastBookRepsoitory> makeDefault() async {
  //   return SembastBookRepsoitory(await Utils.makeSembastDatabase());
  // }

  static const bookmarksKey = 'bookmarks';

  @override
  Future<void> toggleBookmark(String bookId) async {
    var bookmarks = List<String>.from((await store.record(bookmarksKey).get(db) as List<Object?>?) ?? []);
    printWarning('SembastRepo ${bookmarks.length} $bookmarks');
    if (bookmarks.isEmpty) {
      bookmarks = [bookId];
    } else if (bookmarks.contains(bookId)) {
      bookmarks.remove(bookId);
    } else {
      bookmarks.add(bookId);
    }
    printWarning('after: ${bookmarks.length} $bookmarks');
    await store.record(bookmarksKey).put(db, bookmarks);
  }

  @override
  Future<List<String>> getBookmarks() async {
    final bookmarks = await store.record(bookmarksKey).get(db);
    if (bookmarks == null) {
      store.record(bookmarksKey).put(db, []);
      return [];
    }

    printSuccess('localRepo.getBookmarks() => $bookmarks');
    return List<String>.from(bookmarks as List<dynamic>);
  }
  
  @override
  Stream<List<String>> watchBookmarks() {
    
    return store.record(bookmarksKey)
      .onSnapshot(db)
      .map((b) => List<String>.from((b?.value ?? []) as List<dynamic>));
  }

  @override
  Future<void> deleteBookmarks() async {
    await store.record(bookmarksKey).delete(db);
  }

}



  // @override
  // Future<void> addBookmark(String bookId) async {
  //   final bookmarks = await store.record(bookmarksKey).get(db) as List<String>?;
  //   if (bookmarks == null) {
  //     await store.record(bookmarksKey).put(db, [bookId]);
  //     return;
  //   }
  //   await store.record(bookmarksKey).put(db, [...bookmarks, bookId]);
  // }
  
  // @override
  // Future<void> removeBookmark(String bookId) async {
  //   final bookmarks = await store.record(bookmarksKey).get(db) as List<String>?;
  //   if (bookmarks == null) return;
  //   await store.record(bookmarksKey).put(db, bookmarks..remove(bookId));
  // }

src/features/books/data/TEST.dart

import 'package:sembast/sembast.dart';
import 'package:sembast/sembast_io.dart';

class Todo {
  int? id;
  String name;
  bool completed;

  Todo({
    required this.name,
    this.completed = false,
  });

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'completed': completed,
    };
  }

  factory Todo.fromJson(Map<String, dynamic> json) {
    return Todo(
      name: json['name'],
      completed: json['completed'],
    );
  }
}

class TodoRepository {
  late final Database _database;

  TodoRepository() {
    _initDatabase();
  }

  Future<void> _initDatabase() async {
    final databaseFactory = databaseFactoryIo;
    _database = await databaseFactory.openDatabase('todo_database.db');
  }

  Future<List<Todo>> getAllTodos({String? name, bool? completed}) async {
    final store = intMapStoreFactory.store('todos');
    final finder = Finder(
      filter: Filter.and([
        if (name != null) Filter.matchesRegExp('name', RegExp(name, caseSensitive: true)),
        if (completed != null) Filter.equals('completed', completed),
      ]),
    );
    final todosSnapshot = await store.find(_database);
    return todosSnapshot.map((snapshot) {
      final todo = Todo.fromJson(snapshot.value);
      todo.id = snapshot.key;
      return todo;
    }).toList();
  }

  Future<int> addNewTodo(Todo todo) async {
    final store = intMapStoreFactory.store('todos');
    final todoJson = todo.toJson();
    return await store.add(_database, todoJson);
  }

  Future<void> updateTodo(Todo todo) async {
    final store = intMapStoreFactory.store('todos');
    final todoJson = todo.toJson();
    await store.record(todo.id!).update(_database, todoJson);
  }

  Future<void> deleteTodoById(int id) async {
    final store = intMapStoreFactory.store('todos');
    await store.record(id).delete(_database);
  }
}


src/features/books/data/local_book_repository.dart

import 'package:client/src/features/books/data/sembast_book_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../shared/sembast.dart';

part 'local_book_repository.g.dart';

abstract class LocalBookRepository {


  // Future<void> addBookmark(String bookId);
  // Future<void> removeBookmark(String bookId);
  Future<void> toggleBookmark(String bookId);

  // Future<List<String>> getBookmarks();
  // Future<bool> isBookmarked(String bookId);
  Future<void> deleteBookmarks();
  Stream<List<String>> watchBookmarks();
  Future<List<String>> getBookmarks();
}

@Riverpod(keepAlive: true)
LocalBookRepository localBookRepository(LocalBookRepositoryRef ref) {
  // * Override this in the main method
  return SembastBookRepsoitory(ref.watch(sembastDatabaseProvider)!);
}

src/features/books/domain/filtering_source.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'filtering_source.freezed.dart';
part 'filtering_source.g.dart';

@freezed
class FilteringSource with _$FilteringSource {
  factory FilteringSource({
    required List<String> tags,
    required List<String> genres,
  }) = _FilteringSource;

  factory FilteringSource.fromJson(Map<String, dynamic> json) => 
      _$FilteringSourceFromJson(json);
}

src/features/books/domain/filters.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import 'book.dart';

part 'filters.freezed.dart';
part 'filters.g.dart';

@freezed
class Filters with _$Filters {
  factory Filters({
    @JsonKey(includeIfNull: false) String? ofProfile,
    @JsonKey(includeIfNull: false) String? forProfile,
    @JsonKey(includeIfNull: false) String? query,
    @Default([]) List<String> tags,
    @Default([]) List<String> genres,
    @Default([]) List<BookStatus> statuses
  }) = _Filters;

  factory Filters.fromJson(Map<String, dynamic> json) => _$FiltersFromJson(json);
}

src/features/books/domain/book.dart

import 'package:client/src/features/books/domain/filtering_source.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:json_annotation/json_annotation.dart';

import '../../../common/ignore.dart';
import '../../../shared/identifiable.dart';
import '../../chapters/domain/chapter.dart';
import '../../comments/domain/comment.dart';
import '../../profile/domain/profile.dart';

part 'book.freezed.dart';
part 'book.g.dart';

enum BookStatus { completed, inProgress, abandoned }

enum ReadingsState { published, unpublished }

ReadingsState readingsStateFromString(String readingsState) {
  return ReadingsState.values
      .firstWhere((state) => state.name == readingsState);
}

Profile _authorFromJson(Map<String, dynamic> json) {
  return Profile.fromJson(json);
}

String _authorToJson(Profile author) {
  return author.id;
}

@freezed
class Book with _$Book, Identifiable {
  factory Book({
    @JsonKey(name: "_id") @Default("") String id, //     persistent // just always will be here
    @JsonKey(
      toJson: _authorToJson,
      fromJson: _authorFromJson
    ) 
    required Profile author,                      // add persistent // required for addiction a new book
    String? coverUrl,                            //     persistent
    @Default("") String name,                     //     persistent
    String? description,                          //     persistent
    @Default(0) int likes,                        //     persistent
    @Default(0) int views,
    @Default(BookStatus.inProgress) BookStatus status,
    @Default(ReadingsState.unpublished) ReadingsState state,
    @Default([]) List<String> tags,                           // optional
    @Default([]) List<String> genres,                         // optional
    @JsonKey(toJson: ignore, includeIfNull: false) List<Comment>? comments,                      // optional
    @JsonKey(toJson: ignore, includeIfNull: false) List<Chapter>? chapters,                       // optional
  
    @Default(false) bool liked,                       // optional
    bool? bookmarked
  }) = _Book;

  factory Book.fromJson(Map<String, dynamic> json) => _$BookFromJson(json);
}

List<Book> bookListFromJson(List<dynamic> list) { 
  return list.map((e) => Book.fromJson(e as Map<String, dynamic>)).toList();
}


extension Lifetime on Book {
  bool exists() => id.isNotEmpty;
}

extension Like on Book {
  Book toggleLike() {
    return copyWith(
      likes: liked ? likes - 1 : likes + 1,
      liked: !liked
    );
  }
}

extension BookmarkExt on Book {
  Book toggleBookmark() {
    return copyWith(
      bookmarked: bookmarked == null ? true : !bookmarked!
    );
  }
}


src/features/books/domain/mutable_book.dart

import 'package:client/src/features/books/domain/filtering_source.dart';

import 'book.dart';


src/features/books/presentation/book_list/book_list_item_widget.dart

import 'package:client/src/features/books/presentation/book_list/book_list_item_widget_controller.dart';
import 'package:client/src/features/books/presentation/widgets/book_status_widget.dart';
import 'package:client/src/features/books/presentation/widgets/readings_state_widget.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/widgets/my_image.dart';
import '../../domain/book.dart';


/// [listDirection] - axis of the list containing this item. 
class BookListItemWidget extends ConsumerStatefulWidget {
  const BookListItemWidget({
    super.key,
    required this.book,
    this.listDirection = Axis.vertical,
  });

  final Book book;
  final Axis listDirection;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _BookListItemWidgetState();
}
class _BookListItemWidgetState extends ConsumerState<BookListItemWidget> {
  
  void showBook() {
    GoRouter.of(context).pushNamed(MyRoute.book.name, params: {
      'id': widget.book.id
    });
  }

  void bookmark() async {
    await ref.watch(bookListItemWidgetControllerProvider(widget.book).notifier)
      .toggleBookmark();
  } 

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(bookListItemWidgetControllerProvider(widget.book));
    final book = state.book;
    return InkWell(
      onTap: showBook,
      child: (widget.listDirection == Axis.horizontal) ? SizedBox(
        width: 160,
        child: Column(
          // mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            SizedBox(
              height: 176,
              width: 160,
              child: MyImage(
                placeholderIcon: const Icon(Icons.book_outlined, 
                  size: Constants.placeholderIconSize,
                  color: Colors.grey, 
                ),
                imageUrl: book.coverUrl,
              )
            ),
            h8gap,
            Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: p8),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(book.name, 
                            style: Theme.of(context).textTheme.titleMedium,
                            overflow: TextOverflow.ellipsis,
                            softWrap: false,
                          ),
                        ),
                        bookmarkIcon(book)
                      ]
                    ),
                    if (book.description != null) 
                      Text(book.description!,
                        style: TextStyle(color: Theme.of(context).colorScheme.outline),
                        overflow: TextOverflow.ellipsis,
                        softWrap: false,
                      ),
                    h4gap,
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          if (state.isMy) ReadingsStateWidget(state: book.state),
                          BookStatusWidget(status: book.status),
                        ],
                      )
                    )
                  ],
                ),
              ),
            ),
          ]
        ),
      ) 
      : Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SizedBox(
            height: 120,
            width: 96,
            child: MyImage(
              placeholderIcon: const Icon(Icons.book_outlined, 
                size: 72,
                color: Colors.grey, 
              ),
              imageUrl: book.coverUrl,
            )
          ),
          w8gap,
          Expanded(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(book.name, 
                        style: Theme.of(context).textTheme.titleMedium,
                        overflow: TextOverflow.ellipsis,
                        softWrap: false,
                      ),
                    ),
                    bookmarkIcon(book)
                  ]
                ),
                if (book.description != null && book.description!.isNotEmpty) 
                  Text(book.description!,
                    overflow: TextOverflow.ellipsis,
                    softWrap: false,
                  ),
                h4gap,
                Row(
                  children: [
                    if (state.isMy) ReadingsStateWidget(state: book.state),
                    const Spacer(),
                    BookStatusWidget(status: book.status),
                  ]
                ),
                h4gap,
                Row(
                  children: [
                    Text(book.author.displayName ?? book.author.name,
                      style: const TextStyle(color: Colors.grey)
                    ),
                    const Spacer(),
                    const Icon(Icons.favorite, size: 16, color: Colors.grey),
                    w4gap,
                    Text(book.likes.toString(), 
                      style: const TextStyle(color: Colors.grey)
                    ),
                    w8gap,
                  ]
                )
              ]
            ),
          )
        ]
      ),
    );
  }

  Widget bookmarkIcon(Book book) {
    return InkWell(
      onTap: bookmark,
      child: Icon(book.bookmarked ?? false 
        ? Icons.bookmark 
        : Icons.bookmark_outline),
    );
  }
}

src/features/books/presentation/book_list/book_list_widget.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:flutter/material.dart';

import '../../domain/book.dart';
import 'book_list_item_widget.dart';

class BookListWidget extends StatelessWidget {
  const BookListWidget({
    super.key,
    required this.books,
    this.listDirection = Axis.horizontal
  });

  final List<Book> books;
  final Axis listDirection;

  @override
  Widget build(BuildContext context) {
    return listDirection == Axis.horizontal 
      ? SingleChildScrollView(
        scrollDirection: listDirection, 
        child: IntrinsicHeight(
          child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ...books.map((b) => Padding(
                  padding: const EdgeInsets.only(left: p16),
                  child: BookListItemWidget(
                    book: b, 
                    listDirection: listDirection
                  ),
                )).toList(),
                w16gap
              ] 
            )
        ),
      )
      : ListView.separated(
        itemCount: books.length,
        scrollDirection: listDirection,
        padding: const EdgeInsets.all(p16),
        itemBuilder: (context, i) {
          return BookListItemWidget(
            book: books[i], 
            listDirection: listDirection
          );
        },
        separatorBuilder: (context, index) => listDirection == Axis.horizontal 
          ? w8gap 
          : h8gap, 
      );
  }
}


src/features/books/presentation/book_list/book_list_item_widget_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/book.dart';

part 'book_list_item_widget_state.freezed.dart';

@freezed
class BookListItemWidgetState with _$BookListItemWidgetState {
  factory BookListItemWidgetState({
    required Book book,
    @Default(false) bool isMy
  }) = _BookListItemWidgetState;
}

src/features/books/presentation/book_list/book_list_item_widget_controller.dart


import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_item_widget_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../application/local_bookmarks_provider.dart';

part 'book_list_item_widget_controller.g.dart';

@riverpod
class BookListItemWidgetController extends _$BookListItemWidgetController {
  BookRepository get bookRepo => ref.watch(bookRepositoryProvider);

  @override
  BookListItemWidgetState build(Book book) {
    printSuccess('building BookListItemWidgetController state = ${book.state} bookmarked = ${book.bookmarked ?? "null"}'); 
    return BookListItemWidgetState(
      book: book.copyWith(
        bookmarked: ref.watch(myIdProvider) == null 
          ? ref.watch(localBookmarksControllerProvider.notifier) 
              .isBookmarked(book.id) 
          : book.bookmarked 
      ),
      isMy: ref.watch(myIdProvider) == book.author.id
    );
  }

  Future<bool> toggleBookmark() async {
    final isToggled = await bookRepo.toggleBookmark(state.book.id);
    state = state.copyWith(book: state.book.toggleBookmark());
    return isToggled;
  }

}

src/features/books/presentation/edit_book/edit_book_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/common/widgets/description_form_field.dart';
import 'package:client/src/common/widgets/my_image.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/edit_book/edit_book_screen_controller.dart';
import 'package:client/src/features/books/presentation/widgets/book_status_dropdown.dart';
import 'package:client/src/features/books/presentation/widgets/tags_genres_widget.dart';
import 'package:client/src/features/localization/application/ext.dart';
import 'package:client/src/features/localization/application/ll.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/constants/constants.dart';
import '../../../../shared/utils.dart';
import '../../../profile/domain/profile.dart';
import '../../application/books_changed_event.dart';

class EditBookScreen extends ConsumerStatefulWidget {
  const EditBookScreen({
    super.key,
    required this.book
  });

  factory EditBookScreen.add(String ofProfile) => EditBookScreen(
    book: Book(author: Profile(id: ofProfile))
  );

  final Book book;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _EditBookScreenState();
}
class _EditBookScreenState extends ConsumerState<EditBookScreen> {
  EditBookScreenController get cont => 
    ref.watch(editBookScreenControllerProvider(widget.book).notifier);

  void onSave() async {
    Book? updatedBook = await cont.save();
    if (updatedBook != null) {
      ref.read(pubSub.notifier).push(BookEditedEvent(updatedBook));
      if (context.mounted) context.pop();
    }
  }
  void onStatusChanged(BookStatus? newStatus) {
    cont.status = newStatus!;
  }
  void onImageTap() {
    cont.pickImage();
  }
  void onNameChanged(String newName) {
    cont.name = newName;
  }
  void onDescriptionChanged(String newDescription) {
    cont.description = newDescription;
  }
  void onToggleTag(String tag) {
    printSuccess('onToggleTag $tag');
    cont.toggleTag(tag);
  }
  void onToggleGenre(String genre) {
    printSuccess('onToggleGenre $genre');
    cont.toggleGenre(genre);
  }
  void onDelete() async {
    final deletedSuccessfully = await cont.deleteThisBook();
    if (deletedSuccessfully) {
      ref.watch(pubSub.notifier).push(BookDeletedEvent());
      if (context.mounted) {
        context.pop();
        context.pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(editBookScreenControllerProvider(widget.book));
    final book = state.book;
    final ll = curLl(context)!;
    return Scaffold(
      appBar: AppBar(
        title: Text(book.name),
      ),
      body: ListView(
        padding: const EdgeInsets.all(p16),
        children: [
          BookStatusDropdown(
            value: book.status,
            onChanged: onStatusChanged,
          ),
          h16gap,
          Center(
            child: MyImage(
              onTap: onImageTap,
              imageUrl: book.coverUrl,
              size: const Size(p232, p304),
            ),
          ),
          h16gap,
          TextFormField(
            initialValue: book.name,
            onChanged: onNameChanged,
            decoration: InputDecoration(
              labelText: ll.name
            ),
          ),
          h16gap,
          DescriptionFormField(
            initialValue: book.description,
            onChanged: onDescriptionChanged
          ),
          h16gap,
          TagsGenresWidget(
            originTags: state.tags,
            tags: book.tags,
            originGenres: state.genres,
            genres: book.genres,
            onTagTap: onToggleTag,
            onGenreTap: onToggleGenre,
          ),
          if (state.book.exists()) OutlinedButton(
            style: OutlinedButton.styleFrom(
              foregroundColor: Theme.of(context).colorScheme.error
            ),
            onPressed: onDelete,
            child: Text("delete".hardcoded),
          ),
          // Text(Utils.prettyJson(state.toJson())),
          const SizedBox(height: p72)
        ]
      ),
      floatingActionButton: FloatingActionButton.extended(
        label: Text(ll.book.saveBook),
        icon: const Icon(Icons.check),
        onPressed: onSave,
      ),
    );
  }
}

src/features/books/presentation/edit_book/edit_book_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/book.dart';

part 'edit_book_screen_state.freezed.dart';
part 'edit_book_screen_state.g.dart';

@freezed
class EditBookScreenState with _$EditBookScreenState {
  factory EditBookScreenState({
    required Book book,
    @Default([]) List<String> genres,
    @Default([]) List<String> tags
  }) = _EditBookScreenState;

  factory EditBookScreenState.fromJson(Map<String, dynamic> json) => 
      _$EditBookScreenStateFromJson(json);
}

src/features/books/presentation/edit_book/edit_book_screen_controller.dart

import 'dart:io';

import 'package:client/src/common/mutable_list.dart';
import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/edit_book/edit_book_screen_state.dart';
import 'package:client/src/shared/utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/log.dart';

part 'edit_book_screen_controller.g.dart';

@riverpod
class EditBookScreenController extends _$EditBookScreenController {
  BookRepository get bookRepo => ref.watch(bookRepositoryProvider);

  @override
  EditBookScreenState build(Book book) {
    printInfo('EditBookScreenController built');
    bookRepo.getFilteringSource()
      .then((source) => state = state.copyWith(
        genres: source.genres, 
        tags: source.tags
      ));
    return EditBookScreenState(book: book.copyWith());
  }

  set status(BookStatus s) { 
    state = state.copyWith(book: state.book.copyWith(status: s));
  }
  set name(String n) { 
    state = state.copyWith(book: state.book.copyWith(name: n));
  }
  set description(String d) { 
    state = state.copyWith(book: state.book.copyWith(description: d));
  }
  
  Future<void> pickImage() async {
    final path = await Utils.pickImage();
    state = state.copyWith(book: state.book.copyWith(coverUrl: path));
  }

  void toggleGenre(String genre) {
    state = state.copyWith(
      book: state.book.copyWith(
        genres: state.book.genres.copyToggle(genre)
      )
    );
  }

  void toggleTag(String tag) {
    state = state.copyWith(
      book: state.book.copyWith(
        tags: state.book.tags.copyToggle(tag)
      )
    );
  }

  Future<Book?> save() async {
    try {
      String? newDownloadUrl = await _saveCurrentCoverToFirebase();
      late Book bookToUpdate;
      // если картинка есть, сохраним ее и поставим новый url.
      if (newDownloadUrl != null) {
        bookToUpdate = state.book.copyWith(coverUrl: newDownloadUrl);
      // если ее нет, то будем отправлять просто с этим null.
      } else {
        bookToUpdate = state.book.copyWith();
      }
      printError(bookToUpdate);

      if (bookToUpdate.id.isNotEmpty) {
        return await bookRepo.updateBook(bookToUpdate);
      } else {
        return await bookRepo.addBook(bookToUpdate);
      }
    } catch (e) {
      printError(e);
      return null;
    }
  }

  /// ее задача только сохранять картинку в firebase, и вернуть url
  Future<String?> _saveCurrentCoverToFirebase() async {
    if (state.book.coverUrl == null) return null;
    if (state.book.coverUrl!.startsWith('https://')) return null;
    return Utils.saveToFirebase('covers/${state.book.id}', File(state.book.coverUrl!));
  }

  Future<bool> deleteThisBook() async {
    return bookRepo.deleteBook(state.book.id);
  }
}

src/features/books/presentation/books/profile_books_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';
import 'package:client/src/features/books/application/books_changed_event.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/pagination_list_callback_factory.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/log.dart';
import '../../../../common/pagination/pagination_controller.dart';
import '../../../../common/pagination/simple_pagination_list_screen.dart';
import '../../../../common/pub_sub.dart';
import '../../../auth/application/my_id_provider.dart';
import '../../data/book_repository.dart';
import '../../domain/book.dart';
import '../../domain/filters.dart';
import '../book_list/book_list_item_widget.dart';

class ProfileBooksScreen extends ConsumerWidget {
  ProfileBooksScreen({
    super.key,
    required this.ofProfile
  });

  final String ofProfile;

  PaginationItemsCallback<Book>? callback;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    callback ??= PaginationCallbackFactory.instance
          .createProfileBooksCallback(ref, ofProfile);
    final cont = ref.watch(paginationListWidgetControllerProvider(callback!).notifier);
    ref.listen(pubSub, (prev, next) {
      if (next is BooksChangedEvent) cont.refresh();
    });
    final ll = ref.watch(currentLocalizationProvider);

    return Scaffold(
      body: SimplePaginationListScreen<Book>(
        callback: callback!,
        title: ll.screenTitle.profileBooks,
        itemBuilder: (context, item) {
          return BookListItemWidget(book: item);
        },
      ),
      floatingActionButton: ofProfile == ref.watch(myIdProvider) 
        ? FloatingActionButton.extended(
          onPressed: () {
            context.pushNamed(MyRoute.addBook.name,
              params: { 'id': ofProfile }
            );
          }, 
          icon: const Icon(Icons.add),
          label: Text('Add new book'.hardcoded)
        ) 
        : null,
    );
  }
}

src/features/books/presentation/books/books_screen.dart

import 'package:client/src/common/pagination/page_list_widget.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_item_widget.dart';
import 'package:client/src/features/books/presentation/books/books_screen_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/constants/constants.dart';
import 'books_screen_app_bar.dart';

class BooksScreen extends ConsumerStatefulWidget {
  const BooksScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _BooksScreenState();
}
class _BooksScreenState extends ConsumerState<BooksScreen> {
  final refreshController = RefreshController();

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(booksScreenControllerProvider);
    final cont = ref.watch(booksScreenControllerProvider.notifier);
    
    return Scaffold(
      appBar: BooksAppBar(),
      body: state.when(
        data: (books) => PageListWidget(
          paginationController: cont, 
          refreshController: refreshController, 
          child: ListView.separated(
            padding: const EdgeInsets.all(p16),
            separatorBuilder: (context, i) => h8gap,
            itemCount: books.length,
            itemBuilder: (context, index) {
              return BookListItemWidget(book: books[index]);
            },
          ),
        ),
        error: defaultErrorHandler,
        loading: defaultLoading
      )
    );
  }
}

src/features/books/presentation/books/books_screen_app_bar.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/router/menu_button_leading.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/utils/debounce.dart';
import '../../../localization/application/ll.dart';
import '../book_filters/books_query_state.dart';


class BooksAppBar extends StatelessWidget with PreferredSizeWidget {
@override
  final Size preferredSize;

  BooksAppBar({Key? key}) : preferredSize = const Size.fromHeight(56.0), super(key: key);

  final debouncer = Debouncer();

  @override
  Widget build(BuildContext context) {
    return Consumer(
      builder: (context, ref, child) {
        return AppBar(
          leading: const MenuButtonLeading(),
          title: TextFormField(
            initialValue: ref.watch(booksQueryState),
            decoration: InputDecoration(
              border: InputBorder.none,
              contentPadding: EdgeInsets.zero,
              hintText: curLl(context)!.searchPlaceholder
            ),
            onChanged: (v) {
              debouncer.debounce(() {
                ref.watch(booksQueryState.notifier).state = v;
              });
            }
          ),
          actions: [
            IconButton(
              icon: Icon(Icons.filter_alt_outlined),
              onPressed: () {
                context.goNamed(MyRoute.bookFilters.name);
              }
            )
          ]
        );
      },
    );
  }
}

src/features/books/presentation/books/books_screen_controller.dart


import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/books/domain/filters.dart';
import 'package:client/src/features/books/presentation/book/book_screen_controller.dart';
import 'package:client/src/features/books/presentation/books/books_screen.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/log.dart';
import '../../domain/book.dart';
import '../book_filters/books_filters_state.dart';
import 'books_screen_state.dart';

part 'books_screen_controller.g.dart';

@riverpod
class BooksScreenController extends _$BooksScreenController
    with PaginationController<Book> {
  BookRepository get bookRepo => ref.watch(bookRepositoryProvider);

  @override
  FutureOr<List<Book>> build() async {
    printSuccess('BooksScreenController rebuilt');
    return await getItems(0);
  }

  @override
  List<Book> get listState => state.value!;

  @override
  set listState(List<Book> newBooks) {
    printSuccess(newBooks.length);

    state = AsyncData(newBooks);
  }
  
  @override
  PaginationItemsCallback<Book> get getItems => (int from) {
    return bookRepo.getBooks(ref.watch(booksFiltersStateProvider), from);
  };


}

src/features/books/presentation/books/books_screen_state.dart

import 'package:client/src/features/books/domain/filters.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../domain/book.dart';

part 'books_screen_state.freezed.dart';

@freezed
class BooksScreenState with _$BooksScreenState {
  factory BooksScreenState({
    @Default(AsyncValue.loading()) AsyncValue<List<Book>> books,
    required Filters filters
  }) = _BooksScreenState;
}

src/features/books/presentation/book_filters/books_filters_screen_controller.dart

import 'package:client/src/common/mutable_list.dart';
import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/books/domain/filtering_source.dart';
import 'package:client/src/features/books/presentation/book_filters/books_filters_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../domain/book.dart';
import 'books_query_state.dart';

part 'books_filters_screen_controller.g.dart';

@riverpod
class BooksFiltersScreenController extends _$BooksFiltersScreenController {

  @override
  FutureOr<FilteringSource> build() async {
    return ref.watch(bookRepositoryProvider).getFilteringSource();
  }

  void updateQuery(String newQuery) => 
    ref.read(booksQueryState.notifier).state = newQuery;
  
  void toggleTag(String tag) {
    final filters = ref.read(booksFiltersStateProvider);
    ref.read(booksFiltersStateProvider.notifier).state = filters.copyWith(
      tags: filters.tags.copyToggle(tag)
    );
  }

  void toggleGenre(String genre) {
    final filters = ref.read(booksFiltersStateProvider);
    ref.read(booksFiltersStateProvider.notifier).state = filters.copyWith(
      genres: filters.genres.copyToggle(genre)
    );
  }

  void updateStatuses(List<BookStatus> statuses) {
    ref.read(booksFiltersStateProvider.notifier).update((filters) {
      return filters.copyWith(statuses: statuses);
    });
  }
  
}

src/features/books/presentation/book_filters/books_filters_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/widgets/book_status_dropdown.dart';
import 'package:client/src/features/books/presentation/widgets/tags_genres_widget.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/application/ext.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/utils/debounce.dart';
import 'books_filters_screen_controller.dart';
import 'books_filters_state.dart';

class BooksFiltersScreen extends ConsumerStatefulWidget {
  const BooksFiltersScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _BooksFiltersScreenState();
}
class _BooksFiltersScreenState extends ConsumerState<BooksFiltersScreen> {

  final debouncer = Debouncer();

  @override
  Widget build(BuildContext context) {
    final ll = ref.watch(currentLocalizationProvider);
    final state = ref.watch(booksFiltersScreenControllerProvider);
    final cont = ref.watch(booksFiltersScreenControllerProvider.notifier);
    final filters = ref.watch(booksFiltersStateProvider);
    return state.when(
      data: (source) {
        return Scaffold(
          appBar: AppBar(
            title: Text(ll.screenTitle.filters)
          ),
          body: ListView(
            padding: const EdgeInsets.only(top: p8, left: p16, right: p16),
            children: [
              TextFormField(
                decoration: InputDecoration(
                  labelText: 'query'.hardcoded
                ),
                onChanged: (v) {
                  debouncer.debounce(() {
                    cont.updateQuery(v);
                  });
                }
              ),
              h16gap,
              SegmentedButton<BookStatus>(
                selected: filters.statuses.toSet(),
                segments: [
                  ButtonSegment(
                    value: BookStatus.inProgress,
                    label: Text(ll.bookStatus(BookStatus.inProgress)),
                  ),
                  ButtonSegment(
                    value: BookStatus.completed,
                    label: Text(ll.bookStatus(BookStatus.completed)),
                  ),
                  ButtonSegment(
                    value: BookStatus.abandoned,
                    label: Text(ll.bookStatus(BookStatus.abandoned)),
                  ),
                ],
                multiSelectionEnabled: true,
                emptySelectionAllowed: true,
                onSelectionChanged: (statuses) {
                  cont.updateStatuses(statuses.toList());
                },
              ),
              TagsGenresWidget(
                originTags: source.tags,
                tags: filters.tags,
                originGenres: source.genres,
                genres: filters.genres,
                onTagTap: cont.toggleTag,
                onGenreTap: cont.toggleGenre
              )
            ]
          )
        );
      },
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}

src/features/books/presentation/book_filters/books_filters_state.dart

import 'package:client/src/features/books/domain/filters.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'books_query_state.dart';

final booksFiltersStateProvider = StateProvider((ref) {
  return Filters(query: ref.watch(booksQueryState));
});

src/features/books/presentation/book_filters/books_query_state.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

final booksQueryState = StateProvider<String>((ref) => "");

src/features/books/presentation/book/book_screen_controller.dart

import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/data/book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/book/book_screen_state.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:client/src/shared/utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../application/local_bookmarks_provider.dart';

part 'book_screen_controller.g.dart';

@riverpod
class BookScreenController extends _$BookScreenController {
  BookRepository get bookRepo => ref.watch(bookRepositoryProvider);

  FutureOr<BookScreenState> build(String bookId) async {
    final book = await bookRepo.getBook(bookId);
    return BookScreenState(
      book: book.copyWith(
        bookmarked: ref.watch(myIdProvider) == null 
          ? ref.watch(localBookmarksControllerProvider.notifier)
              .isBookmarked(book.id)
          : book.bookmarked 
      ),
      isMy: ref.watch(myIdProvider) == book.author.id,
    );
  }

  Future<void> refresh() async {
    try {
      state = AsyncData(state.value!.copyWith(book: await bookRepo.getBook(bookId)));
    } catch (e) {
      Utils.showMessage(ref, "Can't refresh book");
    }
  }

  Future<bool> toggleLike() async {
    final isToggled = await bookRepo.toggleLike(state.value!.book.id);
    if (isToggled) {
      state = AsyncData(state.value!.copyWith(book: state.value!.book.toggleLike()));
    }
    return isToggled;
  }

  Future<bool> toggleBookmark() async {
    final isToggled = await bookRepo.toggleBookmark(state.value!.book.id);
    state = AsyncData(state.value!.copyWith(book: state.value!.book.toggleBookmark()));
    return isToggled;
  }
  
  void bookUpdated(Book newBook) {
    state = AsyncValue.data(state.value!.copyWith(book: newBook));
  }

  void changeBookState() async {
    try {
      final newState = await bookRepo.changeState(state.value!.book.id);
      state = AsyncData(
        state.value!.copyWith(
          book: state.value!.book.copyWith(
            state: newState
          )
        )
      );
    } on StateChangeNotPermitted catch (_) {
      Utils.showMessage(ref, ref.watch(currentLocalizationProvider).errors.cantPublish);
    }
  }
}

src/features/books/presentation/book/book_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/common/widgets/my_image.dart';
import 'package:client/src/common/widgets/see_all_header.dart';
import 'package:client/src/common/widgets/show_simple_yes_no_dialog.dart';
import 'package:client/src/common/widgets/size_controller_widget.dart';
import 'package:client/src/features/books/application/books_changed_event.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/books/presentation/book/book_screen_controller.dart';
import 'package:client/src/features/books/presentation/book/book_screen_state.dart';
import 'package:client/src/features/books/presentation/widgets/book_status_widget.dart';
import 'package:client/src/features/chapters/application/events.dart';
import 'package:client/src/features/chapters/presentation/chapter/chapter_widget.dart';
import 'package:client/src/features/comments/presentation/comment/comment_widget.dart';
import 'package:client/src/features/comments/presentation/comments/comments_widget.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/profile/presentation/authors/author_widget.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/pub_sub.dart';
import '../../../comments/domain/comment_subject.dart';
import '../../../reports/presentation/report/report_dialog.dart';
import '../widgets/readings_state_widget.dart';

class BookScreen extends ConsumerStatefulWidget {
  const BookScreen({
    super.key,
    required this.bookId,
  });

  final String bookId;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _BookScreenState();
}
class _BookScreenState extends ConsumerState<BookScreen> {
  BookScreenController get cont => 
      ref.watch(bookScreenControllerProvider(widget.bookId).notifier);
  AsyncValue<BookScreenState> get state => 
      ref.watch(bookScreenControllerProvider(widget.bookId));

  final refreshController = RefreshController();

  void onLike() async {
    final isToggled = await cont.toggleLike();
    if (!isToggled) {
      ref.watch(scaffoldMessangerStateProvider)
        .showMessage('Can\'t like'.hardcoded);
    }
  }

  void onBookmark() async {
    final isToggled = await cont.toggleBookmark();
    if (!isToggled) {
      ref.watch(scaffoldMessangerStateProvider)
        .showMessage('Can\'t bookmark'.hardcoded);
    }
  }

  void onEdit() {
    context.pushNamed(MyRoute.editBook.name,
      params: { 'id': widget.bookId },
      extra: ref.watch(bookScreenControllerProvider(widget.bookId)).value!.book
    );
  }

  // publish / unpublish
  void onChangeState() async {
    final ll = ref.watch(currentLocalizationProvider);
    final currentState = ref.watch(bookScreenControllerProvider(widget.bookId)
      .select((state) => state.value!.book.state));

    bool? wantToChangeState = await showSimpleYesNoDialog(
      context, 
      currentState == ReadingsState.published 
        ? ll.wantToHide
        : ll.wantToPublish
    );
    
    if (wantToChangeState != true) return;
    cont.changeBookState();
  }

  void onShowChapters() {
    printInfo(widget.bookId);
    context.pushNamed(MyRoute.chapters.name, 
      params: {
        'id': widget.bookId
      },
      extra: state.value!.book
    );
  }

  void onReport() {
    showReportDialog(context, state.value!.book);
  }

  void onRefresh() async {
    await cont.refresh();
    refreshController.refreshCompleted();
    refreshController.loadComplete();
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(bookScreenControllerProvider(widget.bookId));
    final ll = ref.watch(currentLocalizationProvider);
    ref.listen(pubSub, (prev, next) {
      if (next is BookEditedEvent) {
        cont.bookUpdated(next.updatedBook);
      } else if (next is ChaptersEditedEvent) {
        cont.refresh();
      }
    });
    return state.when(
      data: (state) {
        final book = state.book;

        return Scaffold(
          appBar: AppBar(
            title: Text(book.name),
            actions: [
              PopupMenuButton(
                itemBuilder: (context) {
                  return [
                    PopupMenuItem(
                      onTap: onReport,
                      child: Text('report'.hardcoded)
                    )
                  ];
                }
              ),
            ],
          ),
          body: SmartRefresher(
            controller: refreshController,
            onRefresh: onRefresh,
            child: ListView(
              children: [
                Stack(
                  children: [
                    Center(
                      child: MyImage(
                        placeholderIcon: const Icon(Icons.book_outlined, color: Colors.grey, size: p96),
                        imageUrl: book.coverUrl,
                        size: const Size(p232, p304),
                      ),
                    ),
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: state.isMy 
                        ? IconButton(
                          icon: const Icon(Icons.edit),
                          onPressed: onEdit
                        )
                        : IconButton(
                          icon: Icon(book.bookmarked ?? false 
                            ? Icons.bookmark 
                            : Icons.bookmark_outline),
                          onPressed: onBookmark
                        )
                    )
                  ]
                ),
                h16gap,
                Text(book.name, 
                  style: Theme.of(context).textTheme.headlineMedium,
                  textAlign: TextAlign.center,
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: p16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          BookStatusWidget(status: book.status),
                          if (state.isMy) ...[
                            w8gap,
                            Container(
                              color: Theme.of(context).colorScheme.outline,
                              width: 1,
                              height: 20,
                            ),
                            w8gap,
                            InkWell(
                              onTap: onChangeState,
                              child: ReadingsStateWidget(state: book.state)
                            )
                          ],
                          const Spacer(),
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(book.likes.toString(), 
                                style: Theme.of(context).textTheme.labelLarge
                              ),
                              IconButton(
                                icon: Icon(book.liked 
                                  ? Icons.favorite 
                                  : Icons.favorite_outline),
                                onPressed: onLike,
                              ),
                              Text(book.views.toString(),
                                style: Theme.of(context).textTheme.labelLarge
                                  ?.copyWith(color: Colors.grey),
                              ),
                              const Icon(Icons.remove_red_eye_outlined, 
                                color: Colors.grey
                              )
                            ]
                          ),
                        ]
                      ),
                      Text(book.description ?? ll.profile.noDescriptionPlaceholder,
                        style: Theme.of(context).textTheme.bodyLarge
                      ),
                      h8gap,
                      Align(
                        alignment: Alignment.topLeft,
                        child: Wrap(
                          spacing: p8,
                          children: [
                            ...book.genres.map((g) => FilterChip(
                              elevation: 8,
                              selected: false,
                              onSelected: (s) {},
                              label: Text(g),
                            )).toList(),
                            ...book.tags.map((g) => FilterChip(
                              selected: false,
                              onSelected: (s) {},
                              label: Text(g)
                            )).toList(),
                          ]
                        ),
                      ),
                      h8gap,
                      AuthorWidget(profile: book.author),
                    ]
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(p16),
                  child: SeeAllHeader(
                    labelText: 'Chapters'.hardcoded,
                    onSeeAll: onShowChapters,
                  ),
                ),
                ...book.chapters?.map((ch) => ChapterWidget(chapter: ch)).toList() ?? [
                  ListTile(
                    title: Text("no chapters")
                  )
                ],
                Padding(
                  padding: const EdgeInsets.all(p16),
                  child: CommentsWidget(
                    subjectId: book.id, 
                    subjectName: CommentSubjects.book
                  ),
                )
              ],
            ),
          )
        );
      },
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}


src/features/books/presentation/book/book_screen_state.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'book_screen_state.freezed.dart';

@freezed
class BookScreenState with _$BookScreenState {
  factory BookScreenState({
    required Book book,
    @Default(false) bool isMy
  }) = _BookScreenState;
}

src/features/books/presentation/widgets/tags_genres_widget.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:flutter/material.dart';

import '../../../../common/constants/constants.dart';

class TagsGenresWidget extends StatelessWidget {
  const TagsGenresWidget({
    super.key,
    required this.originTags,
    required this.tags,
    required this.originGenres,
    required this.genres,
    required this.onTagTap,
    required this.onGenreTap,
  });

  final List<String> originTags;
  final List<String> tags;
  final List<String> originGenres;
  final List<String> genres;
  final void Function(String tag) onTagTap;
  final void Function(String tag) onGenreTap;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        h16gap,
        Text('Genres: '.hardcoded, style: Theme.of(context).textTheme.titleMedium!.copyWith(
          color: Theme.of(context).colorScheme.outline
        )),
        const Divider(height: p16),
        Wrap(
          spacing: p8,
          children: [
            ...originGenres.map((g) => FilterChip(
              elevation: 8,
              selected: genres.contains(g),
              onSelected: (selected) => onGenreTap(g),
              label: Text(g),
            )).toList(),
          ]
        ),
        h16gap,
        Text('Tags: '.hardcoded, style: Theme.of(context).textTheme.titleMedium!.copyWith(
          color: Theme.of(context).colorScheme.outline
        )),
        const Divider(height: p16),
        Wrap(
          spacing: p8,
          children: [
            ...originTags.map((t) => FilterChip(
              selected: tags.contains(t),
              onSelected: (selected) => onTagTap(t),
              label: Text(t)
            )).toList(),
          ]
        ),
      ]
    );
  }
}

src/features/books/presentation/widgets/info_label_widget.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:flutter/material.dart';

class InfoLabelWidget extends StatelessWidget {
  const InfoLabelWidget({
    super.key,
    required this.labelText,
    this.iconData,
    this.color
  });

  final IconData? iconData;
  final Color? color;
  final String labelText;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(iconData ?? Icons.circle, color: color, size: 12),
        w4gap,
        Text(labelText, 
          style: Theme.of(context).textTheme.labelLarge!.copyWith(
            color: color
          ),
        )
      ]
    );
  }
}

src/features/books/presentation/widgets/book_status_dropdown.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/localization/application/ext.dart';
import 'package:client/src/features/localization/application/ll.dart';
import 'package:flutter/material.dart';

class BookStatusDropdown extends StatelessWidget {
  const BookStatusDropdown({super.key, this.value, this.onChanged});

  final BookStatus? value;
  final void Function(BookStatus? newStatus)? onChanged;

  @override
  Widget build(BuildContext context) {
    final ll = curLl(context)!;
    return DropdownButtonFormField<BookStatus>(
      value: value,
      items: BookStatus.values.map((s) => DropdownMenuItem(
        value: s,
        child: Text(ll.bookStatus(s)),
      )).toList(), 
      onChanged: onChanged,
      decoration: InputDecoration(
        labelText: ll.status
      ),
    );
  }
}

src/features/books/presentation/widgets/readings_state_widget.dart

import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';

import '../../../localization/application/ll.dart';
import '../../domain/book.dart';
import 'info_label_widget.dart';

class ReadingsStateWidget extends StatelessWidget {
  const ReadingsStateWidget({
    super.key,
    required this.state
  });

  final ReadingsState state;

  @override
  Widget build(BuildContext context) {
    final ll = curLl(context)!;
    switch (state) {
      case ReadingsState.published: return InfoLabelWidget(
        labelText: ll.book.published,
        color: AppColors.published(context)
      );
      case ReadingsState.unpublished: return InfoLabelWidget(
        labelText: ll.book.unpublished, 
        color: AppColors.unpublished
      );
    }
  }
}

src/features/books/presentation/widgets/book_status_widget.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:flutter/material.dart';

import '../../../../shared/constants.dart';
import '../../../localization/application/ll.dart';
import 'info_label_widget.dart';

class BookStatusWidget extends StatelessWidget {
  const BookStatusWidget({
    super.key,
    required this.status
  });

  final BookStatus status;

  @override
  Widget build(BuildContext context) {
    final ll = curLl(context)!;
    switch (status) {
      case BookStatus.completed: return InfoLabelWidget(
        labelText: ll.book.completed,
        color: AppColors.completed
      );
      case BookStatus.inProgress: return InfoLabelWidget(
        labelText: ll.book.inProgress, 
        color: AppColors.inProgress(context)
      );
      case BookStatus.abandoned: return InfoLabelWidget(
        labelText: ll.book.abandoned,
        color: AppColors.abandoned
      );
    }
  }
}

src/features/profile/application/current_profile_id.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// current profile to show on the fullscreen
// final currentProfileIdProvider = StateProvider<String>((ref) {
//   print("currentProfileIdProvider updated");
//   return "";
// });

src/features/profile/application/currently_edited_profile.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// used by EditProfileWidget and EditProfileScreenController
final currentlyEditedProfileProvider = StateProvider<Profile>((ref) {
  throw UnimplementedError();
});

src/features/profile/data/profile_repository.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/books/data/local_book_repository.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/shared/dio.dart';
import 'package:client/src/shared/err.dart';
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../auth/application/my_id_provider.dart';


class ProfileRepository {
  final Dio _dio;
  final String? _myId;
  final LocalBookRepository localBook;

  ProfileRepository(this._dio, this._myId, this.localBook);

  Future<List<Profile>> getProfiles([
    String query = "", 
    int from = 0,
    int pageSize = 20, 
  ]) => err<List<Profile>>(() async {
    final resp = await _dio.get('profiles', queryParameters: {
      'query': query,
      'from': from,
      'pageSize': pageSize,
    });
    return profileListFromJson(List<Map<String, dynamic>>.from(resp.data['data']));
  });

  Future<Profile> getProfile(String? id) async {
    if (id == null) throw UnauthenticatedException();
    try {
      final resp = await _dio.get('profiles/$id');
      final profile = Profile.fromJson(resp.data['data']);
      printInfo('profilebooks: ${profile.books?.map((b) => {'b': b.bookmarked, 'name': b.name})}');
      return profile;
    } on DioError catch (e) {
      // TODO: что блин тут делать?
      printError("myerror");
      printError("printError() => ${e.runtimeType} was rethrown from ProfileRepository");
      rethrow;
    }
  }

  Future<bool> isUniqueName(String name) async {
    final resp = await _dio.get('profiles/is-unique-name', 
      queryParameters: {
        'name': name,
        if (_myId != null) 'uid': _myId
      }
    );
    printInfo(Uri(path: 'profiles/is-unique-name', queryParameters: {
      'name': name,
      if (_myId != null) 'uid': _myId
    }).toString());
    return resp.data['data'] as bool;
  }

  Future<Profile> updateProfile(Profile profile) async {
    final resp = await _dio.put("profiles/${profile.id}", 
      data: profile.toJson()
    );
    final updatedProfile = Profile.fromJson(resp.data['data']);
    return updatedProfile;
  }

  Future<bool> subscribe(String subscribeToId) async {
    try {
      final resp = await _dio.post('profiles/subscribe/$subscribeToId');
      return resp.data['data'] as bool;
    } catch (e) {
      return false;
    }
  }

  Future<bool> unsubscribe(String unsubscribeFromId) async {
    final resp = await _dio.post('profiles/unsubscribe/$unsubscribeFromId');
    return resp.data['data'] as bool;
  }

  /// подписан ли я на кого-то с subscriberId. 
  Future<bool> isSubscribed(String subscriberId) async {
    final resp = await _dio.post('profiles/isSubscribed/$subscriberId');
    return resp.data['data'] as bool;
  }
  /// подписан ли он на меня
  Future<bool> isMySubscriber(String subscriberId) async {
    // TODO: implement
    throw UnimplementedError();
  }

  Future<List<Profile>> subscribers([
    String? profileId, 
    int from = 0, 
    int pageSize = 20
  ]) async {
    printSuccess("profileId = ${profileId}");
    String id = profileId == null || profileId.isEmpty ? _myId! : profileId;
    printSuccess("myId = $_myId");
    printSuccess("id = ${id}");
    final resp = await _dio.get('profiles/$id/subscribers', queryParameters: {
      'from': from,
      'pageSize': pageSize
    });
    printSuccess(resp.data);
    return profileListFromJson(List<Map<String, dynamic>>.from(resp.data['data']));
  }
  
  Future<List<Profile>> subscriptions([
    String? profileId, 
    int from = 0, 
    int pageSize = 20
  ]) async {
    String id = profileId ?? _myId!;
    final resp = await _dio.get('profiles/$id/subscriptions', queryParameters: {
      'from': from,
      'pageSize': pageSize
    });
    return profileListFromJson(List<Map<String, dynamic>>.from(resp.data['data']));
  }

  Future<void> saveBookmarks(List<String> bookmarks) async {
    if (_myId == null) throw UnauthenticatedException();
    await _dio.post('profiles/$_myId/bookmarks', data: { 'bookmarks': bookmarks });
  }

  Future<List<Book>> getBookmarks([int from = 0, int pageSize = 20]) async {
    if (_myId == null) {
      final ids = await localBook.getBookmarks();
      if (ids.isEmpty) return List.empty();
      final resp = await _dio.get('books', queryParameters: {
        'ids': await localBook.getBookmarks(),
        'from': from,
        'pageSize': pageSize
      });
      return bookListFromJson(resp.data['data']);
    }
    final resp = await _dio.get('profiles/$_myId/bookmarks', queryParameters: {
      'from': from,
      'pageSize': pageSize
    });
    return bookListFromJson(resp.data['data']);
  }
}

final profileRepositoryProvider = Provider((ref) {
  return ProfileRepository(ref.watch(dioProvider), ref.watch(myIdProvider), ref.watch(localBookRepositoryProvider));
});

src/features/profile/domain/profile.dart

import 'package:client/src/common/ignore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../../common/log.dart';
import '../../../shared/identifiable.dart';
import '../../books/domain/book.dart';

part 'profile.freezed.dart';
part 'profile.g.dart';

enum Gender {
  m,
  f,
  other,
  preferNotToSay
}

@freezed
class Profile with _$Profile, Identifiable {
  factory Profile({
    @JsonKey(name: "_id") @Default("") String id,
    @Default("") String name,
    String? avatarUrl,
    String? displayName,
    String? description,
    int? age,
    Gender? gender,
    @Default("") String email,
    @JsonKey(toJson: ignore, includeIfNull: false) int? subscribers,
    @JsonKey(toJson: ignore, includeIfNull: false) int? subscriptions,
    @JsonKey(toJson: ignore, includeIfNull: false) int? booksCount,
    @JsonKey(toJson: ignore, includeIfNull: false) List<Book>? books,
    // подписан ли я на этого пользователя. Null, если я без аккаунта
    @JsonKey(toJson: ignore, includeIfNull: false) bool? isSubscribed,
  }) = _Profile;

  factory Profile.fromJson(Map<String, dynamic> json) => _$ProfileFromJson(json);
}

extension ProfileExt on Profile {
  Profile setSubscribed(bool subscribed) {
    return copyWith(
      subscribers: subscribed ? (subscribers ?? 0) + 1 : subscribers! - 1,
      isSubscribed: subscribed
    );
  }
}

profileListFromJson(List<dynamic> list) {
  return list.map((p) => Profile.fromJson(p as Map<String, dynamic>))
    .toList();
}

src/features/profile/presentation/authors/author_widget_controller.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../common/log.dart';
import '../../../../shared/scaffold_messanger.dart';
import '../../data/profile_repository.dart';

part 'author_widget_controller.g.dart';

@riverpod
class AuthorWidgetController extends _$AuthorWidgetController {
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);

  @override
  Profile build(Profile profile) {
    return profile;
  }

  Future<void> subscribe() async {
    final subscribedSuccessfully = await profileRepo.subscribe(state.id);
    if (subscribedSuccessfully) {
      state = state.setSubscribed(true);
      ref.watch(scaffoldMessangerStateProvider).showMessage('Subscribed ${profile.name}'.hardcoded);
    }
    printInfo(state);
  }

  Future<void> unsubscribe() async {
    await profileRepo.unsubscribe(state.id);
    state = state.setSubscribed(false);
    ref.watch(scaffoldMessangerStateProvider).showMessage('${profile.name} unsubscribed'.hardcoded);
    printInfo(state);
  }

}

src/features/profile/presentation/authors/author_widget.dart

import 'package:client/src/common/widgets/my_image.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/authors/author_widget_controller.dart';
import 'package:client/src/features/profile/presentation/profile/profile_action_button.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/log.dart';
import '../profile/profile_screen_controller.dart';

class AuthorWidget extends ConsumerWidget {
  AuthorWidget({
    super.key,
    required this.profile,
    this.listDirection = Axis.vertical
  });

  Axis listDirection;
  Profile profile;


  Future<void> subscribe(WidgetRef ref) async {
    bool subscribed = 
      await ref.read(profileScreenControllerProvider(profile.id).notifier).subscribe();
  }
  Future<void> unsubscribe(WidgetRef ref) async {
    bool unsubscribed = 
      await ref.read(profileScreenControllerProvider(profile.id).notifier).unsubscribe();
  }
  
  void view(BuildContext context, WidgetRef ref) {
    context.pushNamed(MyRoute.profile.name,
      params: { 'id': profile.id }
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(authorWidgetControllerProvider(profile));
    final cont = ref.watch(authorWidgetControllerProvider(profile).notifier);

    return InkWell(
      onTap: () => view(context, ref),
      child: (listDirection == Axis.vertical)
        ? Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            MyImage(
              imageUrl: state.avatarUrl,
              size: const Size.fromRadius(48),
              placeholderIconSize: 48,
            ),
            w8gap,
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(state.displayName ?? state.name,
                    style: Theme.of(context).textTheme.titleMedium
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Icon(
                        Icons.people_outlined, 
                        size: 24,
                        color: Theme.of(context).colorScheme.outline,
                      ),
                      w4gap,
                      Text(state.subscribers.toString(),
                        textAlign: TextAlign.right,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.outline
                        )
                      ),
                    ]
                  )
                ]
              ),
            ),
            w8gap,
            if (state.isSubscribed != null) 
              state.isSubscribed!
                ? IconButton(
                  onPressed: () async {
                    await cont.unsubscribe();
                  },
                  icon: const Icon(Icons.person_remove_alt_1)
                )
                : IconButton(
                  onPressed: () async {
                    await cont.subscribe();
                  },
                  icon: const Icon(Icons.person_add_alt_1)
                ),
          ]
        )
        : SizedBox(
          child: Text(profile.name)
        ),
    );
  }
}

src/features/profile/presentation/authors/authors_screen.dart

import 'dart:async';

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pagination/page_list_widget.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/profile/presentation/authors/author_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/log.dart';
import '../../domain/profile.dart';
import 'authors_screen_app_bar.dart';
import 'authors_screen_controller.dart';

class AuthorsScreen extends ConsumerStatefulWidget {
  const AuthorsScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _AuthorsScreenState();
}
class _AuthorsScreenState extends ConsumerState<AuthorsScreen> {
  final refreshController = RefreshController();

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(authorsScreenControllerProvider);

    return Scaffold(
      appBar: AuthorsAppBar(),
      body: state.when(
        data: (authors) => PageListWidget(
          paginationController: ref.watch(authorsScreenControllerProvider.notifier),
          refreshController: refreshController, 
          child: ListView.separated(
            padding: const EdgeInsets.all(p8),
            separatorBuilder: (context, i) => h8gap,
            itemCount: authors.length,
            itemBuilder: (context, index) {
              return AuthorWidget(profile: authors[index]);
            },
          ),
        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      )
    );
    // return state.when(
    //   data: (authors) {
    //     return Scaffold(
    //       appBar: AuthorsAppBar(),
    //       body: PageListWidget(
    //         paginationController: ref.watch(authorsScreenControllerProvider.notifier),
    //         refreshController: refreshController, 
    //         child: ListView.separated(
    //           padding: const EdgeInsets.all(p8),
    //           separatorBuilder: (context, i) => h8gap,
    //           itemCount: authors.length,
    //           itemBuilder: (context, index) {
    //             return AuthorWidget(profile: authors[index]);
    //           },
    //         ),
    //       ),
    //     );
    //   },
    //   loading: defaultLoading,
    //   error: defaultErrorHandler,
    // );
  }
}

src/features/profile/presentation/authors/authors_screen_app_bar.dart

import 'package:client/src/features/localization/application/ll.dart';
import 'package:client/src/features/profile/presentation/authors/authors_query_state.dart';
import 'package:client/src/router/menu_button_leading.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/utils/debounce.dart';

class AuthorsAppBar extends StatelessWidget with PreferredSizeWidget {
  AuthorsAppBar({Key? key}) : preferredSize = const Size.fromHeight(56.0), super(key: key);
  
  @override
  final Size preferredSize;

  final debouncer = Debouncer();

  @override
  Widget build(BuildContext context) {
    return Consumer(
      builder: (context, ref, child) {
        return AppBar(
          leading: const MenuButtonLeading(),
          title: TextFormField(
            decoration: InputDecoration(
              border: InputBorder.none,
              contentPadding: EdgeInsets.zero,
              hintText: curLl(context)!.searchPlaceholder
            ),
            onChanged: (v) {
              debouncer.debounce(
                () => ref.read(authorsQueryStateProvider.notifier).state = v
              );
            }
          )
        );
      },
    );
  }
}

src/features/profile/presentation/authors/authors_query_state.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final authorsQueryStateProvider = StateProvider<String>((ref) {
  return "";
});

src/features/profile/presentation/authors/authors_screen_controller.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/page_list.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/authors/authors_query_state.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

class AuthorsScreenController extends AutoDisposeAsyncNotifier<List<Profile>> 
    with PaginationController<Profile> {
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);

  @override
  FutureOr<List<Profile>> build() {
    printInfo("build AuthorsScreenController");
    listenToQueryChanges();
    return profileRepo.getProfiles(ref.watch(authorsQueryStateProvider));
  }

  void listenToQueryChanges() {
    printSuccess('start listening to query changes');
    ref.listen(authorsQueryStateProvider, (prevQuery, nextQuery) {
      printSuccess('query changes - refreshing');
      refresh();
    });
  }

  // @override
  // Future<void> refresh() async {
  //   String currentQuery = ref.watch(authorsQueryStateProvider);
  //   printInfo(currentQuery);
  //   state = AsyncData(
  //     await profileRepo.getProfiles(currentQuery));
  //   await Future.delayed(const Duration(seconds: 1));
  //   printSuccess('authors refreshed!');
  // }

  // @override
  // Future<bool> addPage() async {
  //   int prevLen = state.value!.length;
  //   await Future.delayed(const Duration(seconds: 1));
  //   state = AsyncData(
  //     state.value!.addPage(await profileRepo.getProfiles(
  //       ref.read(authorsQueryStateProvider), 
  //       state.value!.length + 1))
  //   );
  //   return prevLen < state.value!.length;
  // }

  @override
  List<Profile> get listState => state.value!;

  @override
  set listState(List<Profile> newList) => state = AsyncData(newList);

  @override
  PaginationItemsCallback<Profile> get getItems => (int from) {
    return profileRepo.getProfiles(ref.watch(authorsQueryStateProvider), from);
  };
}

// dependencies нужно для того чтобы контроллер ребилдился, 
// если я overrideWith одного из dependencies.
final authorsScreenControllerProvider = AutoDisposeAsyncNotifierProvider<
  AuthorsScreenController,
  List<Profile>
>(
  () => AuthorsScreenController(),
);

src/features/profile/presentation/edit_profile_screen/edit_profile_screen_state.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'edit_profile_screen_state.freezed.dart';

@freezed
class EditProfileScreenState with _$EditProfileScreenState {
  factory EditProfileScreenState({
    required Profile originalProfile,
  }) = _EditProfileScreenState;

  factory EditProfileScreenState.start(Profile profile) {
    return EditProfileScreenState(
      originalProfile: profile,
    );
  }
}

src/features/profile/presentation/edit_profile_screen/edit_profile_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/features/profile/application/currently_edited_profile.dart';
import 'package:client/src/features/profile/presentation/edit_profile_screen/edit_profile_screen_controller.dart';
import 'package:client/src/features/profile/presentation/edit_profile_widget/edit_profile_widget.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

class EditProfileScreen extends ConsumerStatefulWidget {
  const EditProfileScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _EditProfileScreenState();
}
class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(editProfileScreenControllerProvider);
    final cont = ref.watch(editProfileScreenControllerProvider.notifier);
    
    return Scaffold(
      appBar: AppBar(
        title: Text(ref.watch(currentlyEditedProfileProvider.select((p) => p.name))),
        centerTitle: true,
      ),
      body: ListView(
        padding: const EdgeInsets.all(p16),
        children: const [
          EditProfileWidget(),
          SizedBox(height: 72)
        ]
      ),
      floatingActionButton: FloatingActionButton.extended(
        isExtended: true,
        onPressed: () async {
          bool updated = await cont.saveProfile();
          if (context.mounted && updated) {
            context.pop();
          } else {
            ref.watch(scaffoldMessangerStateProvider).showMessage('Can\'t save'.hardcoded);
          }
        },
        icon: const Icon(Icons.check),
        label: Text("Save Changes".hardcoded)
      ),
    );
  }
}

src/features/profile/presentation/edit_profile_screen/edit_profile_screen_controller.dart

import 'dart:async';
import 'dart:io';

import 'package:client/src/common/log.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/features/profile/application/currently_edited_profile.dart';
import 'package:client/src/features/profile/presentation/edit_profile_widget/edit_profile_widget_controller.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:client/src/shared/utils.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/current_profile_id.dart';
import '../../data/profile_repository.dart';
import '../../domain/profile.dart';
import 'edit_profile_screen_state.dart';

class ProfileEditedPubSubEvent extends PubSubEvent { }

class EditProfileScreenController 
    extends AutoDisposeAsyncNotifier<EditProfileScreenState> {
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);

  @override
  FutureOr<EditProfileScreenState> build() async {
    final profile = ref.read(currentlyEditedProfileProvider);
    return EditProfileScreenState.start(profile.copyWith());
  }

  Future<bool> saveProfile() async {
    Profile editedProfile = ref.watch(currentlyEditedProfileProvider);

    if (editedProfile.avatarUrl != null && !editedProfile.avatarUrl!.startsWith('https://')) {
      var avatarUrl = await Utils.saveToFirebase(
        'avatars/${editedProfile.id}', 
        File(editedProfile.avatarUrl!)
      );
      editedProfile = editedProfile.copyWith(avatarUrl: avatarUrl);
      printInfo('saving with image: $avatarUrl');
    } else {
      /// do nothing
      printInfo("saving with no image");
    }

    printInfo("---- before update: ${editedProfile.toJson()}");
    if (!ref.watch(editProfileWidgetControllerProvider).isUniqueName) return false;
    
    await profileRepo.updateProfile(editedProfile);
    printInfo("saved");
    ref.read(pubSub.notifier).state = ProfileEditedPubSubEvent();
    return true;
  }
}

final editProfileScreenControllerProvider = AutoDisposeAsyncNotifierProvider<
  EditProfileScreenController,
  EditProfileScreenState
>(
  () {
    return EditProfileScreenController();
  },
  dependencies: [
    profileRepositoryProvider,
    currentlyEditedProfileProvider,
    editProfileWidgetControllerProvider,
  ]
);

src/features/profile/presentation/bookmarks/bookmarks_screen_controller.dart

import 'dart:async';

import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'bookmarks_screen_controller.g.dart';

@riverpod
class BookmarksScreenController extends _$BookmarksScreenController 
    with PaginationController<Book> {

  @override
  FutureOr<List<Book>> build() {
    return getItems(0);
  }
  
  @override
  PaginationItemsCallback<Book> get getItems => (int from) {
    return ref.watch(profileRepositoryProvider).getBookmarks(from);
  };

  @override
  set listState(List<Book> newBooks) => state = AsyncData(newBooks);

  @override
  List<Book> get listState => state.value!;

}

src/features/profile/presentation/bookmarks/bookmarks_screen.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/pagination/page_list_widget.dart';
import '../../../../common/widgets/error_handler.dart';
import '../../../books/presentation/book_list/book_list_item_widget.dart';
import 'bookmarks_screen_controller.dart';

class BookmarksScreen extends ConsumerWidget {
  BookmarksScreen({super.key});

  final refreshController = RefreshController();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(bookmarksScreenControllerProvider);
    final cont = ref.watch(bookmarksScreenControllerProvider.notifier);
    return Scaffold(
      appBar: AppBar(
        title: Text('bookmarks'.hardcoded)
      ),
      body: state.when(
        data: (books) => PageListWidget(
          paginationController: cont, 
          refreshController: refreshController, 
          child: ListView.separated(
            padding: const EdgeInsets.all(p8),
            separatorBuilder: (context, i) => h8gap,
            itemCount: books.length,
            itemBuilder: (context, index) {
              return BookListItemWidget(book: books[index]);
            },
          ),
        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      ),
    );
  }
}

src/features/profile/presentation/profile/subscriptions_screen.dart

import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/pagination/simple_pagination_list_screen.dart';
import '../../../../shared/pagination_list_callback_factory.dart';
import '../../../localization/application/current_localization.dart';
import '../../domain/profile.dart';
import '../authors/author_widget.dart';

class SubscriptionsScreen extends ConsumerWidget {
  const SubscriptionsScreen({
    super.key,
    required this.profileId
  });

  final String profileId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SimplePaginationListScreen<Profile>(
      title: ref.watch(currentLocalizationProvider).profile.subscriptions,
      itemBuilder: (context, item) {
        return AuthorWidget(profile: item);
      },
      callback: 
        PaginationCallbackFactory.instance
          .createSubscriptionsCallback(
              ref, profileId)
    );
  }
}

src/features/profile/presentation/profile/profile_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/pub_sub.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/common/widgets/see_all_header.dart';
import 'package:client/src/features/auth/data/auth_repository.dart';
import 'package:client/src/features/books/application/books_changed_event.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/domain/localization.i69n.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/profile/application/current_profile_id.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/edit_profile_screen/edit_profile_screen_controller.dart';
import 'package:client/src/features/profile/presentation/profile/profile_screen_controller.dart';
import 'package:client/src/features/profile/presentation/profile/profile_screen_state.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:logger/logger.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

import '../../../../common/log.dart';
import '../../../../common/widgets/my_image.dart';
import '../../../../router/menu_button_leading.dart';
import '../../../auth/application/my_id_provider.dart';
import '../../../books/presentation/book_list/book_list_widget.dart';
import '../../../reports/presentation/report/report_dialog.dart';
import 'profile_action_button.dart';


class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({
    super.key,
    this.profileId
  });

  final String? profileId;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  AsyncValue<ProfileScreenState> get state => 
    ref.watch(profileScreenControllerProvider(widget.profileId!));

  void showBooks() {
    context.pushNamed(MyRoute.profileBooks.name,
      params: { 'id': widget.profileId! }
    );
  }

  void showSubscribers() {
    context.pushNamed(MyRoute.subscribers.name, 
      params: { 'id': widget.profileId! }
    );
  }

  void showSubscriptions() {
    context.pushNamed(MyRoute.subscriptions.name, 
      params: { 'id': widget.profileId! }
    );
  }
  
  void subscribe() async {
    await ref.watch(profileScreenControllerProvider(widget.profileId!).notifier).subscribe();
  }

  void unsubscribe() async {
    await ref.watch(profileScreenControllerProvider(widget.profileId!).notifier).unsubscribe();
  }

  void onSendMessage() {
    context.pushNamed(MyRoute.chat.name,
      params: { 'id': widget.profileId! },
      extra: Chat(other: ref.watch(profileScreenControllerProvider(widget.profileId!)).value!.profile)
    );
  }

  void edit() {
    context.pushNamed(MyRoute.editProfile.name, 
      params: { 'id': ref.watch(profileScreenControllerProvider(widget.profileId!)).value!.profile.id },
      extra: ref.watch(profileScreenControllerProvider(widget.profileId!)).value!.profile
    );
  }

  void onRefresh() async {
    await ref.watch(profileScreenControllerProvider(widget.profileId!).notifier).refresh();
    refreshController.refreshCompleted();
    refreshController.loadComplete();
  }

  void onReport() {
    showReportDialog(context, state.value!.profile);
  }

  @override
  void initState() { 
    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  final logger = Logger();
  final refreshController = RefreshController();

  @override
  Widget build(BuildContext context) {
    ref.listen(pubSub, (previous, next) {
      if (next is ProfileEditedPubSubEvent || next is BooksChangedEvent) {
        printSuccess('HOOOOOOOOO');
        ref.watch(profileScreenControllerProvider(widget.profileId).notifier)
          .refresh();
      }
    });

    final ll = ref.watch(currentLocalizationProvider);
    final state = ref.watch(profileScreenControllerProvider(widget.profileId));
    
    // вот эта строчка выдаст ошибку если ты не авторизован, потому что value даже не существует. 
    // его не существует потому что сама state будет не data а error.
    // printInfo("got controller (with id=${state.value?.profile.id})");
    
    return state.when(
      data: (state) {
        final tt = Theme.of(context).textTheme;
        final profile = state.profile;
        // Future(() => ref.read(profileScreenTitleProvider.notifier).state = 
        //     profile.name);
        return Scaffold(
          appBar: AppBar(
            leading: GoRouter.of(context).location.contains('profiles'.hardcoded) 
              ? const BackButton()
              : const MenuButtonLeading(),
            actions: [
              PopupMenuButton(
                itemBuilder: (context) => [PopupMenuItem(
                  onTap: onReport,
                  child: Text('report'.hardcoded)
                )]
              )
            ],
            title: Text(profile.name),
          ),
          body: SmartRefresher(
            controller: refreshController,
            onRefresh: onRefresh,
            child: ListView(
              children: [
                Padding(
                  padding: const EdgeInsets.all(p16),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      IntrinsicHeight(
                        child: Row(
                          children: [
                            MyImage(
                              imageUrl: profile.avatarUrl, 
                              placeholderIconSize: 96,
                              size: const Size(p160, p176)
                            ),
                            w8gap,
                            Expanded(
                              child: buildHead(context, profile, ll),
                            )
                          ]
                        ),
                      ),
                      h16gap,
                      Text(profile.description ?? ll.profile.noDescriptionPlaceholder,
                        style: tt.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                        ),
                      ),
                      h8gap,
                      const Divider(),
                      h8gap,
                      SeeAllHeader(
                        labelText: ll.screenTitle.books,
                        onSeeAll: showBooks
                      ),
                    ]
                  ),
                ),
                BookListWidget(books: profile.books ?? [])
              ],
            ),
          ),
        );
      },
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }


  Column buildHead(BuildContext context, Profile profile, Localization ll) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(profile.displayName ?? profile.name, 
          style: Theme.of(context).textTheme.titleLarge,
        ),
        // Text(profile.id, style: Theme.of(context).textTheme.labelSmall),
        h8gap,
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            buildStatistics(
              onTap: showBooks,
              title: profile.booksCount.toString(),
              subtitle: ll.profile.books
            ),
            buildStatistics(
              onTap: showSubscribers,
              title: profile.subscribers.toString(),
              subtitle: ll.profile.subscribers
            ),
            buildStatistics(
              onTap: showSubscriptions,
              title: profile.subscriptions.toString(),
              subtitle: ll.profile.subscriptions
            ),
          ]
        ),
        const Spacer(),
        Row(
          children: [
            const Spacer(),
            ProfileActionButton(
              profileId: profile.id,
              edit: edit,
              subscribe: subscribe,
              unsubscribe: unsubscribe,
            ),
            if (ref.watch(myIdProvider) != profile.id) IconButton(
              icon: Icon(Icons.message),
              onPressed: onSendMessage
            )
          ],
        )
      ]
    );
  }


  InkWell buildStatistics({
    required void Function() onTap, 
    required String title, 
    required String subtitle
  }) {
    return InkWell(
      onTap: onTap,
      child: Column(
        children: [
          Text(title,
            style: Theme.of(context).textTheme.labelSmall
          ),
          Text(subtitle,
            style: Theme.of(context).textTheme.labelSmall
          )
        ]
      ),
    );
  }


}

src/features/profile/presentation/profile/profile_action_button.dart

import 'package:client/src/features/localization/application/current_localization.dart';

import '../../../../common/hardcoded.dart';
import '../../../auth/application/my_id_provider.dart';
import 'profile_screen_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ProfileActionButton extends ConsumerWidget {
  const ProfileActionButton({
    super.key,
    required this.profileId,
    required this.edit, // TODO: or better simply invoke Controller methods from here? Yeah. It's better.
    required this.unsubscribe,
    required this.subscribe
  });

  final String profileId;
  final void Function() edit;
  final void Function() unsubscribe;
  final void Function() subscribe;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(profileScreenControllerProvider(profileId));
    final ll = ref.watch(currentLocalizationProvider);
    return (state.value!.isMy) 
      ? FilledButton.icon(
        icon: const Icon(Icons.mode_edit_outline_outlined),
        label: Text(ll.edit),
        onPressed: edit,
      ) 
      : (state.value!.isSubscribed) 
        ? FilledButton.icon(
          icon: const Icon(Icons.person_remove_alt_1_outlined),
          label: Text(ll.unsubscribe),
          onPressed: unsubscribe
        )
        : FilledButton.icon(
          icon: const Icon(Icons.person_add_alt),
          label: Text(ll.subscribe),
          // поскольку у меня в ProfileScreenState дефолтом стоит subscribed=false, 
          // и если не авторизован то subscribed остается не изменным, то можно 
          // оставить это так. 
          // но для надежности лучше на всех это поставить, наверно...
          onPressed: ref.watch(myIdProvider) != null ? subscribe : null
        );
  }
}

src/features/profile/presentation/profile/profile_screen_state.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'profile_screen_state.freezed.dart';

@freezed
class ProfileScreenState with _$ProfileScreenState {
  factory ProfileScreenState({
    required Profile profile,
    @Default(false) bool isSubscribed, // do I subscribed on this profile?
    @Default(false) bool isMy
  }) = _ProfileScreenState;
}

extension ProfileScreenStateExt on ProfileScreenState {

  ProfileScreenState setSubscribed(bool subscribed) {
    return copyWith(
      isSubscribed: subscribed,
      profile: profile.setSubscribed(subscribed)
    );
  }
  
}

src/features/profile/presentation/profile/subscribers_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/pagination/simple_pagination_list_screen.dart';
import '../../../../shared/pagination_list_callback_factory.dart';
import '../../../localization/application/current_localization.dart';
import '../../domain/profile.dart';
import '../authors/author_widget.dart';

class SubscribersScreen extends ConsumerWidget {
  const SubscribersScreen({
    super.key,
    required this.profileId
  });

  final String profileId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SimplePaginationListScreen<Profile>(
      title: ref.watch(currentLocalizationProvider).profile.subscribers,
      itemBuilder: (context, item) {
        return AuthorWidget(profile: item);
      },
      callback: 
        PaginationCallbackFactory.instance
          .createSubscribersCallback(
              ref, profileId)
    );
  }
}

src/features/profile/presentation/profile/profile_screen_controller.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/profile/application/current_profile_id.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/profile/profile_screen_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'profile_screen_controller.g.dart';

@Riverpod(keepAlive: false)
class ProfileScreenController
    extends _$ProfileScreenController {
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);

  @override
  FutureOr<ProfileScreenState> build(String? profileId) async {
    // final profileId = ref.watch(currentProfileIdProvider);
    printInfo("build ProfileScreenController with profileId = $profileId");
    final profile = await profileRepo.getProfile(profileId);
    final myId = ref.watch(myIdProvider);
    if (myId != null && profile.id != myId) {
      Future(
        () async => 
          state = AsyncData(state.value!.copyWith(
            isSubscribed: await profileRepo.isSubscribed(profile.id)
          ))
      );
    }
    return ProfileScreenState(
      profile: profile, 
      isMy: ref.watch(myIdProvider) == profile.id
    );
  }

  Future<bool> subscribe() async {
    bool subscribedSuccessfully = await profileRepo.subscribe(state.value!.profile.id);
    state = AsyncData(state.value!.setSubscribed(true));
    return subscribedSuccessfully;
  }

  Future<bool> unsubscribe() async {
    bool unsubscribedSuccessfully = await profileRepo.unsubscribe(state.value!.profile.id);
    state = AsyncData(state.value!.setSubscribed(false));
    // TODO: show snackbar
    return unsubscribedSuccessfully;
  }

  Future<void> refresh() async {
    printInfo("refresh()");
    state = await AsyncValue.guard(() async {
      Profile profile = await profileRepo.getProfile(state.value!.profile.id);
      return ProfileScreenState(
          profile: profile, isMy: ref.watch(myIdProvider) == profile.id);
    });
  }
}

src/features/profile/presentation/edit_profile_widget/edit_profile_widget_controller.dart

import 'dart:io';

import 'package:client/src/common/log.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/shared/utils.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../application/currently_edited_profile.dart';
import '../../data/profile_repository.dart';
import 'edit_profile_widget_state.dart';

// part 'edit_profile_widget_controller.g.dart';

class EditProfileWidgetController extends AutoDisposeNotifier<EditProfileWidgetState> {
  ProfileRepository get profileRepo => ref.watch(profileRepositoryProvider);
  
  @override
  EditProfileWidgetState build() {
    printInfo("EditProfileWidgetController build()");
    Future(() => updateName(state.profile.name));
    return EditProfileWidgetState(
      profile: ref.read(currentlyEditedProfileProvider).copyWith()
    );
  }

  Future<void> updateName(String newName) async {
    printInfo('trying to update name to $newName');
    final isUnique = await profileRepo.isUniqueName(newName);
    printInfo("isUnique = $isUnique");
    state = state.copyWith(
      isUniqueName: isUnique,
      profile: state.profile.copyWith(
        name: isUnique ? newName : state.profile.name
      ),
    );
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }

  set gender(Gender g) {
    state = state.copyWith(profile: state.profile.copyWith(gender: g));
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }
  set displayName(String dn) {
    state = state.copyWith(profile: state.profile.copyWith(displayName: dn.isEmpty ? null : dn));
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }
  set age(int? a) {
    state = state.copyWith(profile: state.profile.copyWith(age: a == 0 ? null : a));
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }
  set description(String ds) {
    state = state.copyWith(profile: state.profile.copyWith(description: ds.isEmpty ? null : ds));
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }

  Future<void> chooseImage() async {
    String? path = await Utils.pickImage();
    state = state.copyWith(profile: state.profile.copyWith(avatarUrl: path));
    ref.watch(currentlyEditedProfileProvider.notifier).state = 
      state.profile.copyWith();
  }
}

final editProfileWidgetControllerProvider = NotifierProvider.autoDispose<
  EditProfileWidgetController,
  EditProfileWidgetState
>(
  () => EditProfileWidgetController(),
  dependencies: [
    currentlyEditedProfileProvider,
    profileRepositoryProvider
  ]
);

src/features/profile/presentation/edit_profile_widget/edit_profile_widget.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/features/profile/presentation/edit_profile_widget/edit_profile_widget_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../common/constants/constants.dart';
import '../../../../common/utils/debounce.dart';
import '../../../../common/widgets/description_form_field.dart';
import '../../../../common/widgets/my_image.dart';
import '../../domain/profile.dart';

class EditProfileWidget extends ConsumerStatefulWidget {
  const EditProfileWidget({super.key, this.isAuth = false});

  final bool isAuth;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _EditProfileWidgetState();
}
class _EditProfileWidgetState extends ConsumerState<EditProfileWidget> {
  final nameDebouncer = Debouncer();

  final formFieldKey = GlobalKey<FormFieldState>();

  void nameChanged(String newName) {
    nameDebouncer.debounce(
      () => ref.watch(editProfileWidgetControllerProvider.notifier)
        .updateName(newName)
    );
  }

  void ageChanged(int newAge) {

  }

  void displayNameChanged(String newDisplayName) {

  }

  void descriptionChanged(String newDescription) {

  }

  void genderChanged(Gender newGender) {

  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(editProfileWidgetControllerProvider);
    final cont = ref.watch(editProfileWidgetControllerProvider.notifier);
    final profile = state.profile;
    printInfo(state.isUniqueName);
    formFieldKey.currentState?.validate();
    printInfo(state.isUniqueName);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      mainAxisSize: MainAxisSize.min,
      children: [
        if (!widget.isAuth) ...[
          Center(
            child: MyImage(
              onTap: () {
                cont.chooseImage();
              },
              size: const Size(160, 176),
              imageUrl: profile.avatarUrl,
            ),
          ),
          h16gap,
        ],
        TextFormField(
          key: formFieldKey,
          maxLength: 80,
          initialValue: profile.name,
          decoration: InputDecoration(
            labelText: "name".hardcoded,
          ),
          onChanged: nameChanged,
          validator: (s) {
            if (ref.watch(editProfileWidgetControllerProvider).isUniqueName) {
              printInfo('This name is unique');
              return null;
            } 
            printInfo("This name is already taken");
            return "This name is already taken";
          },
        ),
        h16gap,
        TextFormField(
          initialValue: profile.displayName,
          maxLength: 80,
          decoration: InputDecoration(
            labelText: "display name".hardcoded,
          ),
          onChanged: (newV) {
            cont.displayName = newV;
          }
        ),
        h16gap,
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: TextFormField(
                initialValue: (profile.age ?? 0).toString(), 
                maxLength: 3,
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                  labelText: "age".hardcoded,
                ),
                onChanged: (newV) {
                  cont.age = int.tryParse(newV, radix: 10);
                }
              ),
            ),
            w16gap,
            Expanded(
              child: DropdownButtonFormField<Gender>(
                decoration: InputDecoration(
                  labelText: "gender".hardcoded,
                ),
                isExpanded: true,
                value: profile.gender,
                items: [
                  DropdownMenuItem<Gender>(
                    value: Gender.preferNotToSay,
                    child: Text("prefer not to say".hardcoded),
                  ),
                  DropdownMenuItem<Gender>(
                    value: Gender.other,
                    child: Text("other".hardcoded),
                  ),
                  DropdownMenuItem<Gender>(
                    value: Gender.m,
                    child: Text("male".hardcoded),
                  ),
                  DropdownMenuItem<Gender>(
                    value: Gender.f,
                    child: Text("female".hardcoded),
                  ),
                ], 
                onChanged: (newV) {
                  cont.gender = newV!;
                }
              ),
            ),
          ]
        ),
        if (!widget.isAuth) ...[
            h16gap,
            DescriptionFormField(
              initialValue: profile.description,
              onChanged: (v) {
                cont.description = v;
              },
            ),
          ],
        // Text(profile.toJson().toString())
      ]
    );
  }
}

src/features/profile/presentation/edit_profile_widget/edit_profile_widget_state.dart

import 'package:client/src/features/profile/domain/profile.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'edit_profile_widget_state.freezed.dart';

@freezed
class EditProfileWidgetState with _$EditProfileWidgetState {
  factory EditProfileWidgetState({
    required Profile profile,
    @Default(false) bool isUniqueName
  }) = _EditProfileWidgetState;
}

src/features/notifications/data/notification_repository.dart



import 'dart:convert';

import 'package:client/src/common/log.dart';
import 'package:client/src/shared/sembast.dart';
import 'package:client/src/shared/utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sembast/sembast.dart';

import '../../../shared/constants.dart';
import '../domain/notification.dart';

class NotificationRepository {
  NotificationRepository(this.db);

  final Database db;
  final stref = stringMapStoreFactory.store('notifications');
  
  Future<String> addNotification(MyNotification not) async {
    final json = not.toJson();
    printInfo('repo.addNotification.json = ${const JsonEncoder.withIndent('  ').convert(json)}\n\n');
    return stref.add(db, not.toJson());
  }

  List<MyNotification> _snapshotsToNotifications(List<RecordSnapshot<String, Map<String, Object?>>> snapshots) {
    return snapshots.map((snap) {
      final not = MyNotification.fromJson(snap.value).copyWith(localId: snap.key);
      printInfo(snap);
      printInfo(not);
      return not;
    }).toList();
  }

  Stream<List<MyNotification>> watchNotifications() {
    return stref.query(finder: Finder(sortOrders: [SortOrder(Str.sentTime, false)]))
      .onSnapshots(db)
      .map(_snapshotsToNotifications);
  }

  Future<List<MyNotification>> getNotifications() async {
    final snapshots = await stref.query(
      finder: Finder(sortOrders: [SortOrder(Str.sentTime, false)])
    ).getSnapshots(db);
    return _snapshotsToNotifications(snapshots);
  }

  Future<void> clearNotifications() async {
    await stref.delete(db);
  }

  Future<void> deleteNotification(String id) async {
    await stref.record(id).delete(db);
  }

  static final provider = Provider(
    (ref) => NotificationRepository(ref.watch(sembastDatabaseProvider)!)
  );

  static final notificationsStreamProvider = StreamProvider((ref) {
    final repo = ref.watch(NotificationRepository.provider);
    return repo.watchNotifications();
  });
}

src/features/notifications/data/notification_service.dart

import 'dart:convert' as conv;

import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:client/src/features/notifications/data/notification_repository.dart';
import 'package:client/src/features/notifications/domain/display_notification_model.dart';
import 'package:client/src/features/notifications/domain/notification.dart';
import 'package:dio/dio.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:i69n/i69n.dart';

import '../../../common/log.dart';
import '../../../shared/constants.dart';
import '../../../shared/utils.dart';

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  if (!NotificationService.isInitialized) { 
    printInfo('reinit');
    await NotificationService.init();
  }

  printInfo(const conv.JsonEncoder.withIndent('  ').convert(message.toMap()));
  final db = await Utils.makeSembastDatabase();
  final repo = NotificationRepository(db);

  final String? notificationType = message.data[Str.notificationType];

  printInfo('notification arrived...... . . . . . . .  .   .');

  if (notificationType == null) {
    NotificationService.showNotification(
      body: 'Unexpected Notification Type',
      title: 'Unknown notification'
    );
    return;
  }
  final not = MyNotification.fromJson(message.toMap()..addAll(message.data));
  final notId = await repo.addNotification(not);
  
  final container = ProviderContainer();
  await container.read(localizationControllerProvider.notifier).loadLocale();
  final localization = container.read(currentLocalizationProvider);
  
  final data = DisplayNotificationModel.fromLocalization(localization, not);

  NotificationService.showNotification(body: data.body, title: data.title);
  printSuccess("Handling a background message: ${const conv.JsonEncoder.withIndent('  ').convert(message.toMap())}\nlocal notification id = $notId\n\n");
}


class NotificationService {
  static final flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  static final _mess = FirebaseMessaging.instance;

  static bool _isInitialized = false;
  static bool get isInitialized => _isInitialized;

  static init() async {
    printError('NotificationService.init()');
    await _initFirebaseMessaging();
    const androidInit = AndroidInitializationSettings('mipmap/ic_launcher');
    const iosInit = DarwinInitializationSettings();
    const initNtf = InitializationSettings(android: androidInit, iOS: iosInit);
    await flutterLocalNotificationsPlugin.initialize(initNtf);
    _isInitialized = true;
  }

  static _initFirebaseMessaging() async {
    _mess.setAutoInitEnabled(true);
    // FirebaseMessaging.instance.requestPermission();
    FirebaseMessaging.onMessage.listen(_firebaseMessagingBackgroundHandler);
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  }

  static Future<void> syncToken(Dio dio) async {
    final token = await FirebaseMessaging.instance.getToken() ;
    final resp = await dio.post('notifications/fcm', data: { 
      'token': token
    });
  }

  static requestPermissions() async {
    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.requestPermission();
  }

  static showNotification({required String title, required String body}) async {
    AndroidNotificationDetails det = const AndroidNotificationDetails(
      'chchch',
      'channel1',
      importance: Importance.max,
      priority: Priority.max,
    );

    var not = NotificationDetails(
      android: det,
      iOS: const DarwinNotificationDetails(),
    );
    await flutterLocalNotificationsPlugin.show(0, title, body, not);
  }
}


src/features/notifications/domain/display_notification_model.dart

import 'package:client/src/features/localization/domain/localization.i69n.dart';
import 'package:client/src/features/notifications/domain/notification.dart';
import 'package:i69n/i69n.dart';

class DisplayNotificationModel {
  String title;
  String body;

  DisplayNotificationModel(this.title, this.body);
  
  factory DisplayNotificationModel.fromLocalization(Localization ll, MyNotification not) { 
    final notLoc = ll.notifications;
    final notData = notLoc[not.notificationType] as I69nMessageBundle;
    final title = notData["title"];
    final body = notData["body"];
    final data = not.toJson();

    return DisplayNotificationModel(
      title is Function ? title(data) : title, 
      body is Function ? body(data) : body
    );
  }
}

src/features/notifications/domain/notification.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:sembast/timestamp.dart';

part 'notification.freezed.dart';
part 'notification.g.dart';

class NotificationType {
  static const String newChapter = 'newChapter';
  static const String bookUnpublished = 'bookUnpublished';
  static const String none = 'none';
  static const String reportRejected = 'reportRejected';
  static const String subscribed = 'subscribed';
  static const String commentAnswer = 'commentAnswer';
  // newMessage,
  // bookUpdate,
  // adminAction
}

enum SubjectType {
  profile,
  book
}

@Freezed(unionKey: 'notificationType', unionValueCase: FreezedUnionCase.none)
class MyNotification with _$MyNotification {

  @FreezedUnionValue(NotificationType.newChapter)
  factory MyNotification.newChapter({
    required String notificationType,
    @Default("") String localId,
    @Default("") String messageId,
    @intDate required DateTime sentTime,
    String? book,
    String? bookId,
    String? chapter,
    String? chapterId,
  }) = NewChapterNotification;

  @FreezedUnionValue(NotificationType.bookUnpublished)
  factory MyNotification.bookUnpublished({
    required String notificationType,
    @Default("") String localId,
    @Default("") String messageId,
    @intDate required DateTime sentTime,
    String? book,
    String? bookId
  }) = BookUnpublishedNotification; 

  @FreezedUnionValue(NotificationType.reportRejected)
  factory MyNotification.reportRejected({
    required String notificationType,
    @Default("") String localId,
    @Default("") String messageId,
    @intDate required DateTime sentTime,
    required String subject,
    required String subjectName,
    required String subjectId
  }) = ReportRejectedNotification;

  @FreezedUnionValue(NotificationType.subscribed)
  factory MyNotification.subscribed({
    required String notificationType,
    @Default("") String localId,
    @Default("") String messageId,
    @intDate required DateTime sentTime,
    required String profile,
    required String profileId
  }) = SubscribedNotification;

  @FreezedUnionValue(NotificationType.commentAnswer)
  factory MyNotification.commentAnswer({
    required String notificationType,
    @Default("") String localId,
    @Default("") String messageId,
    @intDate required DateTime sentTime,
    @Default("") String subject,
    @Default("") String subjectName,
    @Default(0) int depth,
  }) = CommentAnswerNotification;

  factory MyNotification.fromJson(Map<String, dynamic> json) => _$MyNotificationFromJson(json);
}

const intDate = JsonKey(fromJson: DateTime.fromMillisecondsSinceEpoch, toJson: intDateToJson);

intDateToJson(DateTime date) {
  return date.millisecondsSinceEpoch;
}

src/features/notifications/presentation/notifications_screen_state.dart

import 'package:freezed_annotation/freezed_annotation.dart';

import '../domain/notification.dart';

part 'notifications_screen_state.freezed.dart';

@freezed
class NotificationsScreenState with _$NotificationsScreenState {
  factory NotificationsScreenState({
    @Default([]) List<MyNotification> notifications
  }) = _NotificationsScreenState;
}

src/features/notifications/presentation/notifications_screen.dart

import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/notifications/domain/display_notification_model.dart';
import 'package:client/src/features/notifications/presentation/notifications_screen_controller.dart';
import 'package:client/src/shared/constants.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../common/constants/constants.dart';

class NotificationsScreen extends ConsumerStatefulWidget {
  const NotificationsScreen({super.key});
  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _NotificationsScreenState();
}
class _NotificationsScreenState extends ConsumerState<NotificationsScreen> {
  @override
  Widget build(BuildContext context) {
    final ll = ref.watch(currentLocalizationProvider);
    final cont = ref.watch(notificationsScreenControllerProvider.notifier);
    final state = ref.watch(notificationsScreenControllerProvider);
    return Scaffold(
      appBar: AppBar(
        title: Text(ll.screenTitle.notifications),
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_forever_outlined),
            onPressed: () {
              cont.clearNotifications();
            }, 
          )
        ]
      ),
      body: state.when(
        data: (state) => ListView.separated(
          padding: const EdgeInsets.all(p16),
          separatorBuilder: (context, i) => h16gap,
          itemCount: state.notifications.length,

          itemBuilder: (context, index) {
            final n = state.notifications[index];
            final data = DisplayNotificationModel.fromLocalization(ll, n);
            return Dismissible(
              key: Key(n.localId),
              onDismissed: (direction) {
                cont.deleteNotification(n.localId);
              },
              child: Card(
                margin: EdgeInsets.zero,
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: p8),
                  child: ListTile(
                    title: Text(data.title),
                    subtitle: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        Text(data.body),
                        Text(Constants.dateFormat.format(n.sentTime), 
                          style: Theme.of(context).textTheme.labelMedium!
                            .copyWith(
                              color: Colors.grey
                            ),
                          textAlign: TextAlign.end
                        )
                      ]
                    ),
                  ),
                ),
              ),
            );
          }

        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      )
    );
  }
}

src/features/notifications/presentation/notifications_screen_controller.dart

import 'package:client/src/features/notifications/data/notification_repository.dart';
import 'package:client/src/features/notifications/presentation/notifications_screen_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'notifications_screen_controller.g.dart';

@riverpod
class NotificationsScreenController extends _$NotificationsScreenController {
  NotificationRepository get notiRepo => ref.watch(NotificationRepository.provider);

  @override
  FutureOr<NotificationsScreenState> build() async {
    final notifications = await notiRepo.getNotifications();
    Future(listenNotificationsChanges);
    return NotificationsScreenState(notifications: notifications);
  }

  void listenNotificationsChanges() {
    ref.listen(NotificationRepository.notificationsStreamProvider, (prev, next) {
      next.when(
        data: (notifications) { 
          state = AsyncData(state.value!.copyWith(notifications: notifications));
        },
        loading: () {},
        error: (e, st) {}
      );
    });
  }

  Future<void> clearNotifications() async {
    notiRepo.clearNotifications();
  }

  Future<void> deleteNotification(String id) async {
    notiRepo.deleteNotification(id);
  }

}

src/features/localization/application/current_localization.dart

import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../domain/localization.i69n.dart';

final currentLocalizationProvider = Provider<Localization>((ref) {
  return ref.watch(localizationControllerProvider).localization;
});

src/features/localization/application/current_locale.dart

import 'package:client/src/features/localization/data/localization_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final currentLocaleProvider = Provider<Locale>((ref) {
  return ref.watch(localizationControllerProvider).locale;
});

src/features/localization/application/ext.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/localization/domain/localization.i69n.dart';

extension LocalizeBookStatus on Localization {
  String bookStatus(BookStatus status) {
    switch (status) {
      case BookStatus.abandoned: return book.abandoned;
      case BookStatus.inProgress: return book.inProgress;
      case BookStatus.completed: return book.completed;
    }
  }
}

extension LocalizeReadingsState on Localization {
  String readingsState(ReadingsState status) {
    switch (status) {
      case ReadingsState.published: return book.published;
      case ReadingsState.unpublished: return book.unpublished;
    }
  }
}

src/features/localization/application/ll.dart

import 'package:flutter/material.dart';

import '../domain/localization.i69n.dart';

/// helper function to obtain current localization from context
Localization? curLl(BuildContext context) {
  return Localizations.of<Localization>(context, Localization);
}

src/features/localization/data/app_localizations_delegate.dart

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../domain/localization.i69n.dart';
import 'localization_state.dart';

/// обычно логика изменения локализации должна быть здесь. Но не сегодня. 
/// Такой себе, адаптер. 
class AppLocalizationsDelegate extends LocalizationsDelegate<Localization> {
  AppLocalizationsDelegate(this._localization);

  final Localization _localization;

  @override
  bool isSupported(Locale locale) {
    return SupportedLocale.values.contains(locale.languageCode);
  }

  @override
  Future<Localization> load(Locale locale) { 
    return SynchronousFuture(_localization);
  }

  @override
  bool shouldReload(covariant LocalizationsDelegate<Localization> old) {
    return false;
  }

}


src/features/localization/data/localization_controller.dart

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../shared/constants.dart';
import 'app_localizations_delegate.dart';
import 'localization_state.dart';


class LocalizationController extends Notifier<LocalizationState> {

  List<LocalizationsDelegate<dynamic>> getDelegates() {
    return [
      AppLocalizationsDelegate(state.localization),
      GlobalMaterialLocalizations.delegate,
      GlobalCupertinoLocalizations.delegate,
      GlobalWidgetsLocalizations.delegate,
    ];
  }

  @override
  LocalizationState build() {
    return LocalizationState.fromLocale(const Locale(SupportedLocale.uk));
  }

  Future<void> changeLocale(Locale newLocale) async {
    final perfs = await SharedPreferences.getInstance();
    await perfs.setString(Str.currentLocale, newLocale.languageCode);
    state = LocalizationState.fromLocale(newLocale);
  }

  Future<void> loadLocale() async {
    final prefs = await SharedPreferences.getInstance();
    String? currentLocale = prefs.getString(Str.currentLocale);
    state = LocalizationState.fromLocale(
      SupportedLocale.localeFromString(currentLocale));
  }
}

/// в нем уж ТОЧНО будет сидеть нужная локаля. В любом случае. 
final localizationControllerProvider = NotifierProvider<
  LocalizationController,
  LocalizationState
>(
  () => LocalizationController()
);

src/features/localization/data/localization_state.dart

import 'package:flutter/material.dart';

import '../domain/localization.i69n.dart';
import '../domain/localization_uk.i69n.dart';

class SupportedLocale {
  static const String en = 'en';
  static const String uk = 'uk';

  static const List<String> values = [en, uk];

  static Locale localeFromString([String? languageCode]) {
    if (languageCode == null) return const Locale(en);
    for (final locale in values) {
      if (locale == languageCode) return Locale(locale);
    }
    throw 'incorrect languageCode "$languageCode"';
  }

  static Localization localizationFromLocale(Locale locale) {
    switch (locale.languageCode) {
      case en: return const Localization();
      case uk: return const Localization_uk();
    }
    throw 'incorrect locale';
  }
  
}

class LocalizationState {

  final Localization localization;
  final Locale locale;

  LocalizationState(this.localization, this.locale) : 
    assert(locale.languageCode == 'en' ||
      localization is Localization_uk && locale.languageCode == 'uk');

  factory LocalizationState.fromLocale(Locale locale) {
    return LocalizationState(
      SupportedLocale.localizationFromLocale(locale),
      locale
    );
  }
}

src/features/localization/domain/localization_uk.i69n.yaml

screenTitle:
  home: Головна
  messages: Повідомлення
  books: Книги
  authors: Автори
  profile: Профіль
  settings: Налаштування
  notifications: Сповіщення
  profileBooks: Книги
  filters: Фільтри
  bookmarks: Закладки
  authentication: Вхід

auth: 
  email: Email
  password: Пароль
  signIn: Ввійти
  signUp: Зареєструватися
  skip: Пропустити
  switchTo(String to): "Перемкнути на $to"

google: Google

settings:
  changeLanguageLabel: Змінтити мову
  onLangChangedLabel(String newLang): "Мову змінено на $newLang!"
  ukrainian([bool of = false]): "${of ? 'Українську' : 'Українська'}"
  english([bool of = false]): "${of ? 'Англійську' : 'Англійська'}"

errors:
  shortPassword: Пароль повинен мати не менше 6 символів
  cannotSubscribeYourself: Ви не можете підписатися на себе.
  cantPublish: "Ви не можете опублікувати цю книгу"
  cannotAddComment: "Вам не дозволено додавати коментарі."

searchPlaceholder: 'введіть запит...'

description: 'опис'
name: 'імʼя'
displayName: 'реальне імʼя'
age: 'вік'

profile: 
  subscribers: 'Підписники'
  subscriptions: 'Підписки'
  books: 'книги'
  noDescriptionPlaceholder: "Без опису..."

edit: "Редагувати"
subscribe: "Підписатися"
unsubscribe: "Відписатися"
seeAll: "Переглянути Всі"

book:
  published: "опубліковано"
  unpublished: "чернетка"
  publish: "опублікувати"
  unpublish: "сховати"
  
  completed: "завершено"
  inProgress: "в процесі"
  abandoned: "кинуто"

  saveBook: "Зберегти книгу"

chapter:
  firstChapterWarning: Це перша глава.
  lastChapterWarning: Це остання глава.

status: "статус"
wantToHide: "Сховати цю книгу?"
wantToPublish: "Опублікувати?"
yes: "Yes"
no: "No"

notifications:
  newChapter:
    title: "Нова глава"
    body(Map<String, dynamic> data): 'Глава \"${data["chapter"]}\" була додана до книги \"${data["chapter"]}\"'
  bookUnpublished:
    title: "Ваша книга схована через порушення правил."
    body(Map<String, dynamic> data): '\"${data["book"]}\" схована. Звʼяжіться з адміністрацією через вкладку \"Повідомлення\"'
  reportRejected:
    title: "Вашу скаргу відхилено"
    body(Map<String, dynamic> data): 'Вашу скаргу на \"${data["subject"]}\" було відхилено. Правила.'
  subscribed:
    title: 'Новий підписник'
    body(Map<String, dynamic> data): 'Користувач ${data["profile"]} підписався на вас.'
  commentAnswer:
    title: 'Нова відповідь'
    body(Map<String, dynamic> data): 'Користувач ${data["profile"]} відповів на ваш коментар.'

report:
  reportDescriptionQuestion: "Будь ласка, надайте детальний опис проблеми, з якою ви зіткнулися. Це допоможе нам ефективно вирішити проблему."
  reportAddedMessage: "Скаргу додано"

src/features/localization/domain/localization.i69n.dart

// ignore_for_file: unused_element, unused_field, camel_case_types, annotate_overrides, prefer_single_quotes
// GENERATED FILE, do not edit!
import 'package:i69n/i69n.dart' as i69n;

String get _languageCode => 'en';
String get _localeName => 'en';

String _plural(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.plural(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);
String _ordinal(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.ordinal(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);
String _cardinal(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.cardinal(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);

class Localization implements i69n.I69nMessageBundle {
  const Localization();
  ScreenTitleLocalization get screenTitle => ScreenTitleLocalization(this);
  AuthLocalization get auth => AuthLocalization(this);
  String get google => "Google";
  SettingsLocalization get settings => SettingsLocalization(this);
  ErrorsLocalization get errors => ErrorsLocalization(this);
  String get searchPlaceholder => "type here...";
  String get description => "description";
  String get name => "name";
  String get displayName => "display name";
  String get age => "age";
  ProfileLocalization get profile => ProfileLocalization(this);
  String get edit => "Edit";
  String get subscribe => "Subscribe";
  String get unsubscribe => "Unsubscribe";
  String get seeAll => "See All";
  BookLocalization get book => BookLocalization(this);
  ChapterLocalization get chapter => ChapterLocalization(this);
  String get status => "status";
  String get wantToHide => "Want to hide the book?";
  String get wantToPublish => "Want to publish the book?";
  String get yes => "Yes";
  String get no => "No";
  NotificationsLocalization get notifications =>
      NotificationsLocalization(this);
  ReportLocalization get report => ReportLocalization(this);
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'screenTitle':
        return screenTitle;
      case 'auth':
        return auth;
      case 'google':
        return google;
      case 'settings':
        return settings;
      case 'errors':
        return errors;
      case 'searchPlaceholder':
        return searchPlaceholder;
      case 'description':
        return description;
      case 'name':
        return name;
      case 'displayName':
        return displayName;
      case 'age':
        return age;
      case 'profile':
        return profile;
      case 'edit':
        return edit;
      case 'subscribe':
        return subscribe;
      case 'unsubscribe':
        return unsubscribe;
      case 'seeAll':
        return seeAll;
      case 'book':
        return book;
      case 'chapter':
        return chapter;
      case 'status':
        return status;
      case 'wantToHide':
        return wantToHide;
      case 'wantToPublish':
        return wantToPublish;
      case 'yes':
        return yes;
      case 'no':
        return no;
      case 'notifications':
        return notifications;
      case 'report':
        return report;
      default:
        return key;
    }
  }
}

class ScreenTitleLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const ScreenTitleLocalization(this._parent);
  String get home => "Home";
  String get messages => "Messages";
  String get books => "Books";
  String get authors => "Authors";
  String get profile => "Profile";
  String get settings => "Settings";
  String get notifications => "Notifications";
  String get profileBooks => "Profile Books";
  String get filters => "Filters";
  String get bookmarks => "Bookmarks";
  String get authentication => "Authentication";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'home':
        return home;
      case 'messages':
        return messages;
      case 'books':
        return books;
      case 'authors':
        return authors;
      case 'profile':
        return profile;
      case 'settings':
        return settings;
      case 'notifications':
        return notifications;
      case 'profileBooks':
        return profileBooks;
      case 'filters':
        return filters;
      case 'bookmarks':
        return bookmarks;
      case 'authentication':
        return authentication;
      default:
        return key;
    }
  }
}

class AuthLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const AuthLocalization(this._parent);
  String get email => "Email";
  String get password => "Password";
  String get signIn => "Sign In";
  String get signUp => "Sign Up";
  String get skip => "Skip";
  String switchTo(String to) => "Switch to $to";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'email':
        return email;
      case 'password':
        return password;
      case 'signIn':
        return signIn;
      case 'signUp':
        return signUp;
      case 'skip':
        return skip;
      case 'switchTo':
        return switchTo;
      default:
        return key;
    }
  }
}

class SettingsLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const SettingsLocalization(this._parent);
  String get changeLanguageLabel => "Change Language";
  String onLangChangedLabel(String newLang) => "Language changed to $newLang!";
  String ukrainian([bool of = false]) => "Ukrainian";
  String english([bool of = false]) => "English";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'changeLanguageLabel':
        return changeLanguageLabel;
      case 'onLangChangedLabel':
        return onLangChangedLabel;
      case 'ukrainian':
        return ukrainian;
      case 'english':
        return english;
      default:
        return key;
    }
  }
}

class ErrorsLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const ErrorsLocalization(this._parent);
  String get shortPassword => "Password must have more than 6 characters";
  String get cannotSubscribeYourself => "Can't subscribe yourself";
  String get cantPublish => "You can't publish this book";
  String get cannotAddComment => "You are not permitted to add comments.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'shortPassword':
        return shortPassword;
      case 'cannotSubscribeYourself':
        return cannotSubscribeYourself;
      case 'cantPublish':
        return cantPublish;
      case 'cannotAddComment':
        return cannotAddComment;
      default:
        return key;
    }
  }
}

class ProfileLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const ProfileLocalization(this._parent);
  String get subscribers => "Subscribers";
  String get subscriptions => "Subscriptions";
  String get books => "books";
  String get noDescriptionPlaceholder => "No description for this user...";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'subscribers':
        return subscribers;
      case 'subscriptions':
        return subscriptions;
      case 'books':
        return books;
      case 'noDescriptionPlaceholder':
        return noDescriptionPlaceholder;
      default:
        return key;
    }
  }
}

class BookLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const BookLocalization(this._parent);
  String get published => "published";
  String get unpublished => "unpublished";
  String get publish => "publish";
  String get unpublish => "unpublish";
  String get completed => "completed";
  String get inProgress => "in progress";
  String get abandoned => "abandoned";
  String get saveBook => "Save book";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'published':
        return published;
      case 'unpublished':
        return unpublished;
      case 'publish':
        return publish;
      case 'unpublish':
        return unpublish;
      case 'completed':
        return completed;
      case 'inProgress':
        return inProgress;
      case 'abandoned':
        return abandoned;
      case 'saveBook':
        return saveBook;
      default:
        return key;
    }
  }
}

class ChapterLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const ChapterLocalization(this._parent);
  String get firstChapterWarning => "This is the first chapter.";
  String get lastChapterWarning => "This is the last chapter.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'firstChapterWarning':
        return firstChapterWarning;
      case 'lastChapterWarning':
        return lastChapterWarning;
      default:
        return key;
    }
  }
}

class NotificationsLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const NotificationsLocalization(this._parent);
  NewChapterNotificationsLocalization get newChapter =>
      NewChapterNotificationsLocalization(this);
  BookUnpublishedNotificationsLocalization get bookUnpublished =>
      BookUnpublishedNotificationsLocalization(this);
  ReportRejectedNotificationsLocalization get reportRejected =>
      ReportRejectedNotificationsLocalization(this);
  SubscribedNotificationsLocalization get subscribed =>
      SubscribedNotificationsLocalization(this);
  CommentAnswerNotificationsLocalization get commentAnswer =>
      CommentAnswerNotificationsLocalization(this);
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'newChapter':
        return newChapter;
      case 'bookUnpublished':
        return bookUnpublished;
      case 'reportRejected':
        return reportRejected;
      case 'subscribed':
        return subscribed;
      case 'commentAnswer':
        return commentAnswer;
      default:
        return key;
    }
  }
}

class NewChapterNotificationsLocalization implements i69n.I69nMessageBundle {
  final NotificationsLocalization _parent;
  const NewChapterNotificationsLocalization(this._parent);
  String get title => "New Chapter";
  String body(Map<String, dynamic> data) =>
      "Chapter \"${data["chapter"]}\" has been added to the book \"${data["book"]}\"";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return key;
    }
  }
}

class BookUnpublishedNotificationsLocalization
    implements i69n.I69nMessageBundle {
  final NotificationsLocalization _parent;
  const BookUnpublishedNotificationsLocalization(this._parent);
  String get title =>
      "Your book is unpublished due to violation of ... something";
  String body(Map<String, dynamic> data) =>
      "\"${data["book"]}\" has been unpublished. Contact administration through \"Messages\" tab";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return key;
    }
  }
}

class ReportRejectedNotificationsLocalization
    implements i69n.I69nMessageBundle {
  final NotificationsLocalization _parent;
  const ReportRejectedNotificationsLocalization(this._parent);
  String get title => "Your report rejected";
  String body(Map<String, dynamic> data) =>
      "Your report on \"${data["subject"]}\" has been rejected. Rules.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return key;
    }
  }
}

class SubscribedNotificationsLocalization implements i69n.I69nMessageBundle {
  final NotificationsLocalization _parent;
  const SubscribedNotificationsLocalization(this._parent);
  String get title => "New subscriber";
  String body(Map<String, dynamic> data) =>
      "The user ${data["profile"]} has been subscribed on you.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return key;
    }
  }
}

class CommentAnswerNotificationsLocalization implements i69n.I69nMessageBundle {
  final NotificationsLocalization _parent;
  const CommentAnswerNotificationsLocalization(this._parent);
  String get title => "New answer";
  String body(Map<String, dynamic> data) =>
      "The user ${data["profile"]} has been answered your comment.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return key;
    }
  }
}

class ReportLocalization implements i69n.I69nMessageBundle {
  final Localization _parent;
  const ReportLocalization(this._parent);
  String get reportDescriptionQuestion =>
      "Please provide a detailed description of the issue you're experiencing. This will help us address the problem effectively.";
  String get reportAddedMessage => "Report added";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'reportDescriptionQuestion':
        return reportDescriptionQuestion;
      case 'reportAddedMessage':
        return reportAddedMessage;
      default:
        return key;
    }
  }
}


src/features/localization/domain/localization.i69n.yaml

screenTitle:
  home: Home
  messages: Messages
  books: Books
  authors: Authors
  profile: Profile
  settings: Settings
  notifications: Notifications
  profileBooks: Profile Books
  filters: Filters
  bookmarks: Bookmarks
  authentication: Authentication

auth: 
  email: Email
  password: Password
  signIn: Sign In
  signUp: Sign Up
  skip: Skip
  switchTo(String to): "Switch to $to"

google: Google

settings:
  changeLanguageLabel: Change Language
  onLangChangedLabel(String newLang): "Language changed to $newLang!"
  ukrainian([bool of = false]): Ukrainian
  english([bool of = false]): English

errors:
  shortPassword: Password must have more than 6 characters
  cannotSubscribeYourself: "Can't subscribe yourself"
  cantPublish: "You can't publish this book"
  cannotAddComment: "You are not permitted to add comments."

searchPlaceholder: 'type here...'

description: 'description'
name: 'name'
displayName: 'display name'
age: 'age'

profile: 
  subscribers: 'Subscribers'
  subscriptions: 'Subscriptions'
  books: 'books'
  noDescriptionPlaceholder: "No description for this user..."

edit: "Edit"
subscribe: "Subscribe"
unsubscribe: "Unsubscribe"
seeAll: "See All"

book:
  published: "published"
  unpublished: "unpublished"
  publish: "publish"
  unpublish: "unpublish"
  
  completed: "completed"
  inProgress: "in progress"
  abandoned: "abandoned"

  saveBook: "Save book"

chapter:
  firstChapterWarning: This is the first chapter.
  lastChapterWarning: This is the last chapter.

status: "status"
wantToHide: "Want to hide the book?"
wantToPublish: "Want to publish the book?"
yes: "Yes"
no: "No"

notifications:
  newChapter:
    title: "New Chapter"
    body(Map<String, dynamic> data): 'Chapter \"${data["chapter"]}\" has been added to the book \"${data["book"]}\"'
  bookUnpublished:
    title: "Your book is unpublished due to violation of ... something"
    body(Map<String, dynamic> data): '\"${data["book"]}\" has been unpublished. Contact administration through \"Messages\" tab'
  reportRejected:
    title: "Your report rejected"
    body(Map<String, dynamic> data): 'Your report on \"${data["subject"]}\" has been rejected. Rules.'
  subscribed:
    title: 'New subscriber'
    body(Map<String, dynamic> data): 'The user ${data["profile"]} has been subscribed on you.'
  commentAnswer:
    title: 'New answer'
    body(Map<String, dynamic> data): 'The user ${data["profile"]} has been answered your comment.'

report:
  reportDescriptionQuestion: "Please provide a detailed description of the issue you're experiencing. This will help us address the problem effectively."
  reportAddedMessage: "Report added"

src/features/localization/domain/localization_uk.i69n.dart

// ignore_for_file: unused_element, unused_field, camel_case_types, annotate_overrides, prefer_single_quotes
// GENERATED FILE, do not edit!
import 'package:i69n/i69n.dart' as i69n;
import 'localization.i69n.dart';

String get _languageCode => 'uk';
String get _localeName => 'uk';

String _plural(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.plural(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);
String _ordinal(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.ordinal(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);
String _cardinal(int count,
        {String? zero,
        String? one,
        String? two,
        String? few,
        String? many,
        String? other}) =>
    i69n.cardinal(count, _languageCode,
        zero: zero, one: one, two: two, few: few, many: many, other: other);

class Localization_uk extends Localization {
  const Localization_uk();
  ScreenTitleLocalization_uk get screenTitle =>
      ScreenTitleLocalization_uk(this);
  AuthLocalization_uk get auth => AuthLocalization_uk(this);
  String get google => "Google";
  SettingsLocalization_uk get settings => SettingsLocalization_uk(this);
  ErrorsLocalization_uk get errors => ErrorsLocalization_uk(this);
  String get searchPlaceholder => "введіть запит...";
  String get description => "опис";
  String get name => "імʼя";
  String get displayName => "реальне імʼя";
  String get age => "вік";
  ProfileLocalization_uk get profile => ProfileLocalization_uk(this);
  String get edit => "Редагувати";
  String get subscribe => "Підписатися";
  String get unsubscribe => "Відписатися";
  String get seeAll => "Переглянути Всі";
  BookLocalization_uk get book => BookLocalization_uk(this);
  ChapterLocalization_uk get chapter => ChapterLocalization_uk(this);
  String get status => "статус";
  String get wantToHide => "Сховати цю книгу?";
  String get wantToPublish => "Опублікувати?";
  String get yes => "Yes";
  String get no => "No";
  NotificationsLocalization_uk get notifications =>
      NotificationsLocalization_uk(this);
  ReportLocalization_uk get report => ReportLocalization_uk(this);
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'screenTitle':
        return screenTitle;
      case 'auth':
        return auth;
      case 'google':
        return google;
      case 'settings':
        return settings;
      case 'errors':
        return errors;
      case 'searchPlaceholder':
        return searchPlaceholder;
      case 'description':
        return description;
      case 'name':
        return name;
      case 'displayName':
        return displayName;
      case 'age':
        return age;
      case 'profile':
        return profile;
      case 'edit':
        return edit;
      case 'subscribe':
        return subscribe;
      case 'unsubscribe':
        return unsubscribe;
      case 'seeAll':
        return seeAll;
      case 'book':
        return book;
      case 'chapter':
        return chapter;
      case 'status':
        return status;
      case 'wantToHide':
        return wantToHide;
      case 'wantToPublish':
        return wantToPublish;
      case 'yes':
        return yes;
      case 'no':
        return no;
      case 'notifications':
        return notifications;
      case 'report':
        return report;
      default:
        return super[key];
    }
  }
}

class ScreenTitleLocalization_uk extends ScreenTitleLocalization {
  final Localization_uk _parent;
  const ScreenTitleLocalization_uk(this._parent) : super(_parent);
  String get home => "Головна";
  String get messages => "Повідомлення";
  String get books => "Книги";
  String get authors => "Автори";
  String get profile => "Профіль";
  String get settings => "Налаштування";
  String get notifications => "Сповіщення";
  String get profileBooks => "Книги";
  String get filters => "Фільтри";
  String get bookmarks => "Закладки";
  String get authentication => "Вхід";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'home':
        return home;
      case 'messages':
        return messages;
      case 'books':
        return books;
      case 'authors':
        return authors;
      case 'profile':
        return profile;
      case 'settings':
        return settings;
      case 'notifications':
        return notifications;
      case 'profileBooks':
        return profileBooks;
      case 'filters':
        return filters;
      case 'bookmarks':
        return bookmarks;
      case 'authentication':
        return authentication;
      default:
        return super[key];
    }
  }
}

class AuthLocalization_uk extends AuthLocalization {
  final Localization_uk _parent;
  const AuthLocalization_uk(this._parent) : super(_parent);
  String get email => "Email";
  String get password => "Пароль";
  String get signIn => "Ввійти";
  String get signUp => "Зареєструватися";
  String get skip => "Пропустити";
  String switchTo(String to) => "Перемкнути на $to";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'email':
        return email;
      case 'password':
        return password;
      case 'signIn':
        return signIn;
      case 'signUp':
        return signUp;
      case 'skip':
        return skip;
      case 'switchTo':
        return switchTo;
      default:
        return super[key];
    }
  }
}

class SettingsLocalization_uk extends SettingsLocalization {
  final Localization_uk _parent;
  const SettingsLocalization_uk(this._parent) : super(_parent);
  String get changeLanguageLabel => "Змінтити мову";
  String onLangChangedLabel(String newLang) => "Мову змінено на $newLang!";
  String ukrainian([bool of = false]) => "${of ? 'Українську' : 'Українська'}";
  String english([bool of = false]) => "${of ? 'Англійську' : 'Англійська'}";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'changeLanguageLabel':
        return changeLanguageLabel;
      case 'onLangChangedLabel':
        return onLangChangedLabel;
      case 'ukrainian':
        return ukrainian;
      case 'english':
        return english;
      default:
        return super[key];
    }
  }
}

class ErrorsLocalization_uk extends ErrorsLocalization {
  final Localization_uk _parent;
  const ErrorsLocalization_uk(this._parent) : super(_parent);
  String get shortPassword => "Пароль повинен мати не менше 6 символів";
  String get cannotSubscribeYourself => "Ви не можете підписатися на себе.";
  String get cantPublish => "Ви не можете опублікувати цю книгу";
  String get cannotAddComment => "Вам не дозволено додавати коментарі.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'shortPassword':
        return shortPassword;
      case 'cannotSubscribeYourself':
        return cannotSubscribeYourself;
      case 'cantPublish':
        return cantPublish;
      case 'cannotAddComment':
        return cannotAddComment;
      default:
        return super[key];
    }
  }
}

class ProfileLocalization_uk extends ProfileLocalization {
  final Localization_uk _parent;
  const ProfileLocalization_uk(this._parent) : super(_parent);
  String get subscribers => "Підписники";
  String get subscriptions => "Підписки";
  String get books => "книги";
  String get noDescriptionPlaceholder => "Без опису...";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'subscribers':
        return subscribers;
      case 'subscriptions':
        return subscriptions;
      case 'books':
        return books;
      case 'noDescriptionPlaceholder':
        return noDescriptionPlaceholder;
      default:
        return super[key];
    }
  }
}

class BookLocalization_uk extends BookLocalization {
  final Localization_uk _parent;
  const BookLocalization_uk(this._parent) : super(_parent);
  String get published => "опубліковано";
  String get unpublished => "чернетка";
  String get publish => "опублікувати";
  String get unpublish => "сховати";
  String get completed => "завершено";
  String get inProgress => "в процесі";
  String get abandoned => "кинуто";
  String get saveBook => "Зберегти книгу";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'published':
        return published;
      case 'unpublished':
        return unpublished;
      case 'publish':
        return publish;
      case 'unpublish':
        return unpublish;
      case 'completed':
        return completed;
      case 'inProgress':
        return inProgress;
      case 'abandoned':
        return abandoned;
      case 'saveBook':
        return saveBook;
      default:
        return super[key];
    }
  }
}

class ChapterLocalization_uk extends ChapterLocalization {
  final Localization_uk _parent;
  const ChapterLocalization_uk(this._parent) : super(_parent);
  String get firstChapterWarning => "Це перша глава.";
  String get lastChapterWarning => "Це остання глава.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'firstChapterWarning':
        return firstChapterWarning;
      case 'lastChapterWarning':
        return lastChapterWarning;
      default:
        return super[key];
    }
  }
}

class NotificationsLocalization_uk extends NotificationsLocalization {
  final Localization_uk _parent;
  const NotificationsLocalization_uk(this._parent) : super(_parent);
  NewChapterNotificationsLocalization_uk get newChapter =>
      NewChapterNotificationsLocalization_uk(this);
  BookUnpublishedNotificationsLocalization_uk get bookUnpublished =>
      BookUnpublishedNotificationsLocalization_uk(this);
  ReportRejectedNotificationsLocalization_uk get reportRejected =>
      ReportRejectedNotificationsLocalization_uk(this);
  SubscribedNotificationsLocalization_uk get subscribed =>
      SubscribedNotificationsLocalization_uk(this);
  CommentAnswerNotificationsLocalization_uk get commentAnswer =>
      CommentAnswerNotificationsLocalization_uk(this);
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'newChapter':
        return newChapter;
      case 'bookUnpublished':
        return bookUnpublished;
      case 'reportRejected':
        return reportRejected;
      case 'subscribed':
        return subscribed;
      case 'commentAnswer':
        return commentAnswer;
      default:
        return super[key];
    }
  }
}

class NewChapterNotificationsLocalization_uk
    extends NewChapterNotificationsLocalization {
  final NotificationsLocalization_uk _parent;
  const NewChapterNotificationsLocalization_uk(this._parent) : super(_parent);
  String get title => "Нова глава";
  String body(Map<String, dynamic> data) =>
      "Глава \"${data["chapter"]}\" була додана до книги \"${data["chapter"]}\"";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return super[key];
    }
  }
}

class BookUnpublishedNotificationsLocalization_uk
    extends BookUnpublishedNotificationsLocalization {
  final NotificationsLocalization_uk _parent;
  const BookUnpublishedNotificationsLocalization_uk(this._parent)
      : super(_parent);
  String get title => "Ваша книга схована через порушення правил.";
  String body(Map<String, dynamic> data) =>
      "\"${data["book"]}\" схована. Звʼяжіться з адміністрацією через вкладку \"Повідомлення\"";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return super[key];
    }
  }
}

class ReportRejectedNotificationsLocalization_uk
    extends ReportRejectedNotificationsLocalization {
  final NotificationsLocalization_uk _parent;
  const ReportRejectedNotificationsLocalization_uk(this._parent)
      : super(_parent);
  String get title => "Вашу скаргу відхилено";
  String body(Map<String, dynamic> data) =>
      "Вашу скаргу на \"${data["subject"]}\" було відхилено. Правила.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return super[key];
    }
  }
}

class SubscribedNotificationsLocalization_uk
    extends SubscribedNotificationsLocalization {
  final NotificationsLocalization_uk _parent;
  const SubscribedNotificationsLocalization_uk(this._parent) : super(_parent);
  String get title => "Новий підписник";
  String body(Map<String, dynamic> data) =>
      "Користувач ${data["profile"]} підписався на вас.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return super[key];
    }
  }
}

class CommentAnswerNotificationsLocalization_uk
    extends CommentAnswerNotificationsLocalization {
  final NotificationsLocalization_uk _parent;
  const CommentAnswerNotificationsLocalization_uk(this._parent)
      : super(_parent);
  String get title => "Нова відповідь";
  String body(Map<String, dynamic> data) =>
      "Користувач ${data["profile"]} відповів на ваш коментар.";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'title':
        return title;
      case 'body':
        return body;
      default:
        return super[key];
    }
  }
}

class ReportLocalization_uk extends ReportLocalization {
  final Localization_uk _parent;
  const ReportLocalization_uk(this._parent) : super(_parent);
  String get reportDescriptionQuestion =>
      "Будь ласка, надайте детальний опис проблеми, з якою ви зіткнулися. Це допоможе нам ефективно вирішити проблему.";
  String get reportAddedMessage => "Скаргу додано";
  Object operator [](String key) {
    var index = key.indexOf('.');
    if (index > 0) {
      return (this[key.substring(0, index)]
          as i69n.I69nMessageBundle)[key.substring(index + 1)];
    }
    switch (key) {
      case 'reportDescriptionQuestion':
        return reportDescriptionQuestion;
      case 'reportAddedMessage':
        return reportAddedMessage;
      default:
        return super[key];
    }
  }
}


src/features/reports/data/report_repository.dart

import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:client/src/features/reports/domain/report_subject.dart';
import 'package:client/src/shared/err.dart';
import 'package:client/src/shared/identifiable.dart';
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../shared/constants.dart';
import '../../../shared/dio.dart';
import '../../profile/domain/profile.dart';
import '../domain/report_type.dart';

class ReportRepostiory {
  final Dio _dio;
  final String? _myId;

  ReportRepostiory(this._dio, this._myId);

  // subject - Book, Comment, Profile
  Future<bool> addReport<T extends Identifiable>(
    T subject,
    String reportType,
    String description
  ) => err(() async {
    String subjectName = ReportSubject.subjectNameFromObject(subject);
    String? defendant = ReportSubject.getDefendant(subject);
    final resp = await _dio.post(Str.dio.reports, data: {
      'subjectName': subjectName,
      'subject': subject.id,
      'reportType': reportType,
      'description': description,
      'author': _myId,
      'defendant': defendant
    });
    return resp.data[Str.dio.data] as bool;
  });

  Future<List<ReportType>> getReportTypes(String? subjectName) async {
    final resp = await _dio.get(Str.dio.reportTypes, queryParameters: { 
      'subjectName': subjectName 
    });
    return reportTypeListFromJson(resp.data[Str.dio.data]);
  }
}

final reportRepositoryProvider = Provider(
  (ref) => ReportRepostiory(ref.watch(dioProvider), ref.watch(myIdProvider)));

src/features/reports/domain/report_subject.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/comments/domain/comment.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../profile/domain/profile.dart';

class ReportSubject {
  static const String book = "Book";
  static const String profile = "Profile";
  static const String comment = "Comment";

  static String subjectNameFromObject(dynamic subject) {
    if (subject is Book) { 
      return book;
    } else if (subject is Profile) {
      return profile;
    } else if (subject is Comment) {
      return comment;
    }
    throw 'incorrect object';
  }

  static String? getDefendant(dynamic subject) {
    final subjectName = subjectNameFromObject(subject);
    String? defendant;
    switch (subjectName) { 
      case ReportSubject.book:
        defendant = (subject as Book).author.id;
        break;
      case ReportSubject.profile:
        defendant = (subject as Profile).id;
        break;
      case ReportSubject.comment:
        defendant = (subject as Comment).author.id;
        break;
    }
    return defendant;
  }
}

src/features/reports/domain/report_type.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'report_type.freezed.dart';
part 'report_type.g.dart';

@freezed
class ReportType with _$ReportType {
  factory ReportType({
    @JsonKey(name: "_id") @Default("") String id,
    @Default("") String name,
    @Default("") String displayName,
    @Default([]) List<String> subjectName,
    @Default("") String description
  }) = _ReportType;

  factory ReportType.fromJson(Map<String, dynamic> json) => _$ReportTypeFromJson(json);
}

reportTypeListFromJson(List<dynamic> list) {
  return list.map((r) => ReportType.fromJson(r as Map<String, dynamic>))
    .toList();
}

src/features/reports/presentation/report_question/report_question_dialog.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/features/localization/application/ll.dart';
import 'package:flutter/material.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:go_router/go_router.dart';

class ReportQuestionDialog extends StatefulWidget {
  const ReportQuestionDialog({super.key});

  @override
  State<ReportQuestionDialog> createState() => _ReportQuestionDialogState();
  
  static Future<String?> show(BuildContext context) async {
    return showDialog(
      context: context,
      builder: (context) => const ReportQuestionDialog()
    );
  }
}

class _ReportQuestionDialogState extends State<ReportQuestionDialog> {
  final descriptionController = TextEditingController();
  @override
  Widget build(BuildContext context) {
    final ll = curLl(context);
    return AlertDialog(
      title: Text(ll!.report.reportDescriptionQuestion),
      content: TextField(
        controller: descriptionController
      ),
      actions: [
        OutlinedButton(
          onPressed: () {
            context.pop();
          },
          child: Text('Cancel'.hardcoded),
        ),
        FilledButton(
          onPressed: () {
            context.pop(descriptionController.text);
          }, 
          child: Text("Send".hardcoded),
        )
      ]
    );
  }
}

src/features/reports/presentation/report/report_dialog_controller.dart


import 'package:client/src/common/log.dart';
import 'package:client/src/features/reports/data/report_repository.dart';
import 'package:client/src/features/reports/domain/report_subject.dart';
import 'package:client/src/features/reports/domain/report_type.dart';
import 'package:client/src/shared/identifiable.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'report_dialog_controller.g.dart';

@riverpod
class ReportDialogController extends _$ReportDialogController {
  ReportRepostiory get reportRepo => ref.watch(reportRepositoryProvider);

  FutureOr<List<ReportType>> build(Identifiable subject) {
    return reportRepo.getReportTypes(ReportSubject.subjectNameFromObject(subject));
  }

  Future<bool> addReport(ReportType type, String description) async {
    try {
      final added = await reportRepo.addReport(subject, type.name, description);
      return added;
    } catch (e) {
      printError(e);
      return Future.value(false);
    }
  }
}

class Mambinio extends StatefulWidget {
  const Mambinio({super.key});

  @override
  State<Mambinio> createState() => _MambinioState();
}

class _MambinioState extends State<Mambinio> {
  @override
  Widget build(BuildContext context) {
    return const Placeholder();
  }
}

src/features/reports/presentation/report/report_dialog.dart

import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/reports/domain/report_type.dart';
import 'package:client/src/features/reports/presentation/report/report_dialog_controller.dart';
import 'package:client/src/features/reports/presentation/report_question/report_question_dialog.dart';
import 'package:client/src/shared/identifiable.dart';
import 'package:client/src/shared/utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../localization/application/ll.dart';

class ReportDialog extends ConsumerStatefulWidget {
  const ReportDialog({super.key, required this.subject});

  final Identifiable subject;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ReportDialogState();
}

class _ReportDialogState extends ConsumerState<ReportDialog> {
  ReportDialogController get cont => 
    ref.watch(reportDialogControllerProvider(widget.subject).notifier);
  AsyncValue<List<ReportType>> get state => 
    ref.watch(reportDialogControllerProvider(widget.subject));

  Future<void> onReportTypeSelected(ReportType reportType) async {
    final description = await ReportQuestionDialog.show(context);
    if (description == null) return;
    final added = await cont.addReport(reportType, description);
    if (added && context.mounted) {
      context.pop();
      final ll = curLl(context)!;
      Utils.showMessagew(ref, ll.report.reportAddedMessage);
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = this.state;
    return Dialog.fullscreen(
      insetAnimationDuration: const Duration(milliseconds: 500),
      insetAnimationCurve: Curves.easeIn,
      child: state.when(
        data: (reportTypes) => Scaffold(
          appBar: AppBar(),
          body: ListView.builder(
            itemCount: reportTypes.length,
            itemBuilder:(context, index) {
              final reportType = reportTypes[index];
              return ListTile(
                onTap: () => onReportTypeSelected(reportType),
                title: Text(reportType.displayName),
                subtitle: Text(reportType.description)
              );
            },
          ),
        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      )
    );
  }
}

Future<void> showReportDialog(BuildContext context, Identifiable subject) {
  return showDialog(
    context: context, 
    builder: (context) => ReportDialog(subject: subject)
  );
}

src/shared/identifiable.dart

import '../features/profile/domain/profile.dart';

mixin Identifiable {
  String get id;
}

mixin Owned {
  Profile get author;
}

src/shared/scaffold_messanger.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final scaffoldMessangerStateProvider = Provider((ref) {
  return GlobalKey<ScaffoldMessengerState>();
});

extension Messanger on GlobalKey<ScaffoldMessengerState> {
  void showMessage(String message) {
    currentState?.showSnackBar(SnackBar(
      behavior: SnackBarBehavior.floating,
      content: Text(message),
    ));
  }
}

src/shared/dio.dart

import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:client/src/shared/utils.dart';
import 'package:dio/dio.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../common/log.dart';
import 'constants.dart';

final dioProvider = Provider((ref) {
  final dio = Dio(
    BaseOptions(
      baseUrl: baseApiUrl
    )
  );
  dio.interceptors.add(QueuedInterceptorsWrapper(
    onRequest: (options, handler) {
      User? user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        printInfo("iterceptor - user is not signed in");
        handler.next(options);
        return;
      }
      FirebaseAuth.instance.currentUser?.getIdToken().then((token) {
        options.headers['authorization'] = 'Bearer $token';
        handler.next(options);
      });
    },
    onError: (e, handler) {
      printError(e);
      printError(e.stackTrace);
      printInfo(e.response?.statusCode);

      if (e.response?.statusCode == 401) {
        Utils.showMessage(ref, "Not signed in.");
      }

      final code = e.response?.data?['error']['code'];
      printInfo(code);
      if (code == 'blockedUserAuth') {
        Utils.showMessage(ref, 'User is blocked');
      }
      
      handler.next(e);
    },
    // onResponse: (response, handler) {
    //   handler.next(response);
    // }
  ));
  return dio;
});

src/shared/utils.dart

import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:sembast/sembast.dart';
import 'package:sembast_web/sembast_web.dart';
import 'package:sembast/sembast_io.dart';

import '../common/log.dart';

class Utils {
  static Future<String?> pickImage() async {
    String? path;
    bool? storageStatus;
    bool? photosStatus;

    if (Platform.isAndroid) {
      final androidInfo = await DeviceInfoPlugin().androidInfo;
      if (androidInfo.version.sdkInt <= 32) {
        storageStatus = await Permission.storage.request().isGranted;
      } else {
        photosStatus = await Permission.photos.request().isGranted;
      }
    }

    if ((storageStatus ?? false) || (photosStatus ?? false)) {
      final image = await ImagePicker().pickImage(source: ImageSource.gallery);
      if (image == null) return null;

      final file = File(image.path);
      printInfo(file.uri);
      printInfo(file.path);
      path = file.path;
    }
    return path;
  }

  static Future<String> saveToFirebase(String where, File what) async {
    var snapshot = await FirebaseStorage.instance
      .ref(where)
      .putFile(what);
    return await snapshot.ref.getDownloadURL();
  }

  static String prettyJson(jsonObject){
    const encoder = JsonEncoder.withIndent("  ");
    return encoder.convert(jsonObject);
  }

  static void showMessage(Ref ref, String message) {
    ref.watch(scaffoldMessangerStateProvider).showMessage(message);
  }

  static void showMessagew(WidgetRef ref, String message) {
    ref.watch(scaffoldMessangerStateProvider).showMessage(message);
  }

  static Future<Database> makeSembastDatabase([String? file]) async {
    late Database db;
    
    if (kIsWeb) {
      db = await databaseFactoryWeb.openDatabase('default.db');
    } else {
      final appDocDir = await getApplicationDocumentsDirectory();
      db = await databaseFactoryIo.openDatabase('${appDocDir.path}/${file ?? 'default.db'}');
    }

    return db;
  }
}

src/shared/err.dart

import 'dart:async';
import 'dart:io';

import 'package:dio/dio.dart';

import '../common/log.dart';
import '../common/widgets/error_handler.dart';

class AppError {
  String code;

  AppError(this.code);
}

Future<T> err<T>(Future<T> Function() func) async {
  try {
    return await func();
  } on DioError catch (e) {
    if (e.type == DioErrorType.unknown && e.error is SocketException) {
      printInfo("ConnectionException thrown from err<T>");
      throw ConnectionException();
    } else if (e.type == DioErrorType.badResponse) {
      throw AppError(e.response!.data['error']['code']);
    }
    rethrow;
  } 
}

src/shared/socket.dart

import 'dart:async';

import 'package:client/src/shared/constants.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/subjects.dart';
import 'package:socket_io_client/socket_io_client.dart';

import '../common/log.dart';
import '../features/messages/domain/message.dart';

Socket socket({String? namespace, Map<dynamic, dynamic>? queryParams}) {
  var options = OptionBuilder()
    .setTransports([ 'websocket' ]);
  
  options = options.setAuthFn((authFn) async {
    if (FirebaseAuth.instance.currentUser == null) return authFn({});
    return authFn({
      "authorization": "Bearer ${await FirebaseAuth.instance.currentUser!.getIdToken()}"
    });
  });
  
  if (queryParams != null) options = options.setQuery(queryParams);

  return io("$baseSocketUrl${namespace ?? ""}", options.build());
}


class IncomingEvents {
  static const String nextMessage = 'nextMessage';
}


class OutcomingEvents {
  static const String subscribeAllMessages = "subscribeAllMessages";
  static const String unsubscribeAllMessages = "unsubscribeAllMessages";
}


class NextMessageHandler {
  NextMessageHandler(this.callback, [this.reportId]) {
    chatsSocket.emit(OutcomingEvents.subscribeAllMessages, reportId);
    chatsSocket.on(IncomingEvents.nextMessage, _listener);
  }

  final String? reportId;

  final void Function(Message nextMessage) callback;

  final chatsSocket = socket(namespace: 'chats');
  final _subject = PublishSubject<Message>();

  Future<void> dispose() async {
    await _subject.close();
    chatsSocket.off(IncomingEvents.nextMessage, _listener);
    chatsSocket.emit(OutcomingEvents.unsubscribeAllMessages, reportId);
    chatsSocket.dispose();
  }

  void _listener(dynamic data) {
    Message message = Message.fromJson(data);
    printInfo('NextMessageHandler._listener');
    callback(message);
  }
  
}

src/shared/pagination_list_callback_factory.dart

import 'package:client/src/features/books/domain/book.dart';
import 'package:client/src/features/chapters/data/chapter_repository.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../common/log.dart';
import '../common/pagination/pagination_controller.dart';
import '../common/pagination/pagination_list_widget_controller.dart';
import '../features/auth/application/my_id_provider.dart';
import '../features/books/data/book_repository.dart';
import '../features/books/domain/filters.dart';
import '../features/profile/application/current_profile_id.dart';
import '../features/profile/data/profile_repository.dart';
import '../features/profile/domain/profile.dart';


/// should be used after you ensure that currentProfileIdProvider is set. 
/// Usualy it's set after you navigate to some profile. 
class PaginationCallbackFactory {
  PaginationCallbackFactory._internal();

  static PaginationCallbackFactory? _instance;

  static PaginationCallbackFactory get instance {
    _instance ??= PaginationCallbackFactory._internal();
    return _instance!;
  }

  PaginationItemsCallback<Profile> createSubscribersCallback(WidgetRef ref, String profileId) {
    return (int from) => 
      ref.watch(profileRepositoryProvider).subscribers(profileId, from);
  }

  PaginationItemsCallback<Profile> createSubscriptionsCallback(WidgetRef ref, String profileId) {
    return (int from) => 
      ref.watch(profileRepositoryProvider).subscriptions(profileId, from);
  }

  PaginationItemsCallback<Book> createProfileBooksCallback(WidgetRef ref, String ofProfile) {
    return (from) {
      // printSuccess('callback called $from, $ofProfile ${ref.watch(myIdProvider)}');
      return ref.watch(bookRepositoryProvider)
        .getBooks(
          Filters(
            ofProfile: ofProfile,
            forProfile: ref.watch(myIdProvider)
          ), 
          from
        );
    };
  }

  PaginationItemsCallback<Chapter> createBookChaptersCallback(WidgetRef ref, String bookId) {
    return (from) {
      return ref.watch(chapterRepositoryProvider)
        .getChapters(bookId, from);
    };
  }
  
  PaginationItemsCallback<Book> createPopularBooksCallback(WidgetRef ref) {
    return (from) {
      return ref.watch(bookRepositoryProvider)
        .getPopularBooks(from);
    };
  }
}


src/shared/constants.dart

// const baseUrl = "http://127.0.0.1:3000/";
// final baseUrl = "http://10.0.2.2:3000/";
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:intl/intl.dart';

class Envs {
  static const String baseUrl = 'BASE_URL';
}

final baseUrl = dotenv.env[Envs.baseUrl];
final baseApiUrl = "${baseUrl}api/v1/";
final baseSocketUrl = baseUrl;

enum MyRoute {
  root,
  auth,

  home,
  chats,
  books, 
    bookFilters,
  // authors,
  profiles,
  myProfile,

  settings,
  notifications,
  bookmarks,

  chat,
  book,
    editBook,
    addBook,
    chapters,
      chapter,
        editChapter,
      addChapter,
  profile,
    editProfile,
    profileBooks,
    subscribers,
    subscriptions,
  blocked,
  popularBooks,
  popularAuthors
}

class Str {
  static const String currentLocale = 'currentLocale';
  static final dio = _DioRouters();
  static const String notificationType = 'notificationType';
  static const String sentTime = 'sentTime';
}

class _DioRouters {
  final String books = 'books';
  final String chapters = 'chapters';
  final String bookId = "bookId";
  final String from = 'from';
  final String state = 'state';
  final String pageSize = 'pageSize';
  final String data = 'data';
  final String reports = 'reports';
  final String reportTypes = 'reports/types';

  String get popularBooks => '$books/popular';

  String chapter(String chapterId) {
    return "$chapters/$chapterId";
  }
  String chapterState(String chapterId) {
    return "${chapter(chapterId)}/$state";
  }
  String chapterNav(String chapterId) {
    return "${chapter(chapterId)}/nav";
  }
}

class AppColors {
  static teritary(BuildContext context) =>
    Theme.of(context).colorScheme.tertiary;

  static const Color completed = Color(0xFFA69F3D);
  static const Color abandoned = Color(0xFF878676);
  static inProgress(BuildContext context) => teritary(context);

  static published(BuildContext context) => teritary(context);
  static const Color unpublished = Color(0xFF7F7571);
  
}

class Constants {
  static final dateFormat = DateFormat("dd/MM/yy HH:mm");  
  static const placeholderIconSize = 96.0;
}


src/shared/sembast.dart

import 'package:client/src/shared/utils.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sembast/sembast.dart';

final sembastDatabaseProvider = Provider<Database?>((ref) {
  final v = ref.watch(sembastDatabaseFutureProvider);
  return v.when(data: (db) => db, error: (e, st) => null, loading: () => null);
});


final sembastDatabaseFutureProvider = FutureProvider((ref) {
  return Utils.makeSembastDatabase();
});

src/common/build_context_ext.dart

import 'package:flutter/material.dart';

extension BuildContextEntension<T> on BuildContext {

  bool get isMobile => MediaQuery.of(this).size.width <= 500.0;
  bool get isSmallTablet => MediaQuery.of(this).size.width > 500.0 && MediaQuery.of(this).size.width < 650.0;
  bool get isTablet => MediaQuery.of(this).size.width >= 650.0 && MediaQuery.of(this).size.width < 1024.0;
  bool get isDesktop => MediaQuery.of(this).size.width >= 1024.0;
  bool get isSmall => MediaQuery.of(this).size.width < 850.0 && MediaQuery.of(this).size.width >= 560.0;

  double get width => MediaQuery.of(this).size.width;
  double get height => MediaQuery.of(this).size.height;
  Size get size => MediaQuery.of(this).size;

  // text styles

  TextStyle? get displayMedium => Theme.of(this).textTheme.displayMedium;

  TextStyle? get displaySmall => Theme.of(this).textTheme.displaySmall;

  TextStyle? get headlineLarge => Theme.of(this).textTheme.headlineLarge;

  TextStyle? get headlineMedium => Theme.of(this).textTheme.headlineMedium;

  TextStyle? get titleLarge => Theme.of(this).textTheme.titleLarge;

  TextStyle? get titleMedium => Theme.of(this).textTheme.titleMedium;

  TextStyle? get titleSmall => Theme.of(this).textTheme.titleSmall;

  TextStyle? get labelLarge => Theme.of(this).textTheme.labelLarge;

  TextStyle? get bodySmall => Theme.of(this).textTheme.bodySmall;

  TextStyle? get titleTextStyle => Theme.of(this).appBarTheme.titleTextStyle;

  TextStyle? get bodyExtraSmall => bodySmall?.copyWith(fontSize: 10, height: 1.6, letterSpacing: .5);

  TextStyle? get bodyLarge => Theme.of(this).textTheme.bodyLarge;

  TextStyle? get dividerTextSmall => bodySmall?.copyWith(letterSpacing: 0.5, fontWeight: FontWeight.w700, fontSize: 12.0);

  TextStyle? get dividerTextLarge => bodySmall?.copyWith(letterSpacing: 1.5, fontWeight: FontWeight.w700, fontSize: 13.0, height: 1.23);

  // colors

  Color get primaryColor => Theme.of(this).primaryColor;

  Color get primaryColorDark => Theme.of(this).primaryColorDark;

  Color get primaryColorLight => Theme.of(this).primaryColorLight;

  Color get primary => Theme.of(this).colorScheme.primary;

  Color get onPrimary => Theme.of(this).colorScheme.onPrimary;

  Color get secondary => Theme.of(this).colorScheme.secondary;

  Color get onSecondary => Theme.of(this).colorScheme.onSecondary;

  Color get cardColor => Theme.of(this).cardColor;

  Color get errorColor => Theme.of(this).colorScheme.error;

  Color get background => Theme.of(this).colorScheme.background;

  // custome theme extensions, You must have to create theme extensions first
  // you can use them with shortcuts as well
  // Gradient get vertical => Theme.of(this).extension<AppThemeExtension>()!.vertical;

  // Gradient get horizontal => Theme.of(this).extension<AppThemeExtension>()!.horizontal;

  // Color get extraLightGrey => Theme.of(this).extension<AppThemeExtension>()!.extraLightGrey;

  // Color get lightGrey => Theme.of(this).extension<AppThemeExtension>()!.lightGrey;

  Future<T?> showBottomSheet(
    Widget child, {
    bool isScrollControlled = true,
    Color? backgroundColor,
    Color? barrierColor,
  }) {
    return showModalBottomSheet(
      context: this,
      barrierColor: barrierColor,
      isScrollControlled: isScrollControlled,
      backgroundColor: backgroundColor,
      builder: (context) => Wrap(children: [child]),
    );
  }

  ScaffoldFeatureController<SnackBar, SnackBarClosedReason> showSnackBar(String message) {
    return ScaffoldMessenger.of(this).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
        // backgroundColor: primary,
      ),
    );
  }

  // Future<bool?> showToast(String message) {
  //   return Fluttertoast.showToast(
  //     msg: message,
  //     toastLength: Toast.LENGTH_SHORT,
  //     gravity: ToastGravity.BOTTOM,
  //     timeInSecForIosWeb: 1,
  //     backgroundColor: primary,
  //     textColor: onPrimary,
  //   );
  // }
}

src/common/mutable_list.dart

extension MutableList<T> on List<T> {
  List<T> copyWith(T item, { bool start = false }) {
    if (start) return [item, ...this];
    return [...this, item];
  }

  List<T> copyWithout(T item) {
    return [...this]..remove(item);
  }

  List<T> copyWithoutWhere(bool Function(T item) predicate) {
    T item = firstWhere(predicate);
    return copyWithout(item);
  }

  List<T> copyToggle(T item, { bool start = false }) {
    return contains(item) ? copyWithout(item) : copyWith(item, start: start);
  }

  List<T> withReplacement(T replacement, bool Function(T item) match) {
    final int index = indexWhere(match);
    return [...this]..replaceRange(index, index + 1, [replacement]);
  }
}

src/common/pub_sub.dart

import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'log.dart';

// class PubSubEvent {}

class PubSubNotifier extends Notifier<PubSubEvent> {

  @override
  PubSubEvent build() => PubSubEvent();

  push(PubSubEvent nextEvent) => state = nextEvent;
}

final pubSub = NotifierProvider<PubSubNotifier, PubSubEvent>(
  () => PubSubNotifier()
);

typedef Subscriber<T extends PubSubEvent> = void Function(T event, void Function() cancel);

class PubSubSubscription {
  final Subscriber _subscriber;

  PubSubSubscription(this._subscriber);

  void cancel() {
    PubSub.instance.unsub(_subscriber);
  }
}

class PubSubEvent {}

class PubSub {
  PubSub._();

  static PubSub? _instance;

  static PubSub get instance {
    _instance ??= PubSub._();
    return _instance!;
  }

  final List<Subscriber> _subscribers = [];

  PubSubSubscription? sub(Subscriber subscriber) {
    if (_subscribers.contains(subscriber)) return null;
    _subscribers.add(subscriber);
    return PubSubSubscription(subscriber);
  }

  void unsub(Subscriber subscriber) {
    _subscribers.remove(subscriber);
  }

  void pub(PubSubEvent event) {
    for (final subscriber in _subscribers) {
      printSuccess('call subscriber');
      subscriber(event, () => unsub(subscriber));
    }
  }
}

src/common/ignore.dart

T? ignore<T>(dynamic _) => null;

src/common/log.dart

// Blue text
void printInfo(Object? object) {
  print('\x1B[34m${object.toString()}\x1B[0m');
}

// Green text
void printSuccess(Object? object) {
  print('\x1B[32m${object.toString()}\x1B[0m');
}

// Yellow text
void printWarning(Object? object) {
  print('\x1B[33m${object.toString()}\x1B[0m');
}

// Red text
void printError(Object? object) {
  print('\x1B[31m${object.toString()}\x1B[0m');
}


src/common/go_router_refresh_stream.dart

import 'dart:async';

import 'package:client/src/common/log.dart';
import 'package:flutter/material.dart';

/// makes GoRouter redirect when stream recevies an event
class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    notifyListeners();
    _subscription = stream.asBroadcastStream().listen(
          (dynamic _) {
            printSuccess("GoRouterRefreshStream - value arrived");
            return notifyListeners();
          },
        );
  }

  late final StreamSubscription<dynamic> _subscription;

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}

src/common/hardcoded.dart

extension Hardcoded on String {
  String get hardcoded => this;
}

src/common/socket_stream.dart

import 'package:client/src/common/log.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:rxdart/subjects.dart';
import 'package:socket_io_client/socket_io_client.dart';


class SocketStream<StreamItemType> {
  Socket socket;
  String socketEvent;
  StreamItemType Function(dynamic data) parse;

  SocketStream({
    required this.socket, 
    required this.socketEvent, 
    required this.parse
  }) {
    setHandlers();
    socket.on("connect", (data) {
      printInfo('connected to ${socket.nsp}');
    });
    socket.on("disconnect", (data) {
      printInfo('disconnected from ${socket.nsp}');
    });
    socket.onReconnect((data) {
      printInfo('reconnect from ${socket.nsp}');
      setHandlers();
    });
  }

  void setHandlers() {
    printInfo('set handlers');
    socket.on(socketEvent, (data) {
      _controller.sink.add(parse(data));
    });
  }

  final _controller = BehaviorSubject<StreamItemType?>.seeded(null);

  Stream<StreamItemType?> get stream => _controller.stream;

  void dispose() {
    socket.dispose();
    _controller.close();
  }
}

src/common/pagination/pagination_list_widget_controller.dart


import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/page_list.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';


class PaginationListWidgetController<Type> 
    extends AutoDisposeFamilyAsyncNotifier<List<Type>, 
      PaginationItemsCallback<Type>>
    with PaginationController<Type> {

  @override
  FutureOr<List<Type>> build(PaginationItemsCallback<Type> arg) async {
    this.getItems = arg;
    printInfo('PaingationListWidgetController<Type> built');
    return getItems(0);
  }

  @override
  late PaginationItemsCallback<Type> getItems;

  @override
  List<Type> get listState => state.value!;
  
  @override
  set listState(List<Type> newList) => state = AsyncData(newList);
}


final paginationListWidgetControllerProvider = 
  AutoDisposeAsyncNotifierProviderFamily<
    PaginationListWidgetController<dynamic>, 
    List<dynamic>, 
    PaginationItemsCallback
  >(
  () => PaginationListWidgetController<dynamic>()
);


src/common/pagination/pagination_controller.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/page_list.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';


typedef PaginationItemsCallback<T> = Future<List<T>> Function(int from);

mixin PaginationController<T> {

  set listState(List<T> newList);
  List<T> get listState;
  PaginationItemsCallback<T> get getItems;
  
  Future<void> refresh() async {
    final firstPage = await getItems(0);
    printWarning('refresh() - pagelen = ${firstPage.length}');
    listState = firstPage;
  }

  /// whether page has been added or not
  Future<bool> addPage() async {
    final page = await getItems(listState.length);
    printWarning('addPage() - pagelen = ${page.length}');
    listState = listState.addPage(page);
    return page.isNotEmpty;
  }
}

src/common/pagination/page_list.dart

extension PageList<T> on List<T> {
  List<T> addPage(List<T> page) {
    return [...this, ...page];
  }
}

src/common/pagination/simple_pagination_list_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/pagination/page_list_widget.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/profile/application/current_profile_id.dart';
import 'package:client/src/features/profile/data/profile_repository.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/authors/author_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

/// [callback] to fetch the data
class SimplePaginationListScreen<T> extends ConsumerWidget {
  SimplePaginationListScreen({super.key, 
    required this.callback,
    required this.itemBuilder,
    this.title = "List"
  });

  final String title;
  final Widget Function(BuildContext context, T item) itemBuilder;
  final refreshController = RefreshController();

  final PaginationItemsCallback<T> callback;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(paginationListWidgetControllerProvider(callback));
    final cont = ref.watch(paginationListWidgetControllerProvider(callback).notifier);
    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        centerTitle: true
      ),
      body: state.when(
        data: (items) => PageListWidget(
          paginationController: cont,
          refreshController: refreshController,
          child: ListView.separated(
            padding: const EdgeInsets.all(p16),
            itemCount: items.length,
            separatorBuilder: (context, index) => h16gap,
            itemBuilder: (context, i) {
              // return AuthorWidget(profile: items[i]);
              return itemBuilder(context, items[i]);
            }
          ),
        ),
        loading: defaultLoading,
        error: defaultErrorHandler
      )
    );
  }
}

src/common/pagination/page_list_widget.dart

import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/pagination_controller.dart';
import 'package:flutter/material.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

class PageListWidget extends StatelessWidget {
  const PageListWidget({
    super.key,
    required this.paginationController,
    required this.refreshController,
    required this.child
  });

  final PaginationController paginationController;
  final RefreshController refreshController;
  final Widget child;


  Future<void> refresh() async {
    await paginationController.refresh();
    refreshController.refreshCompleted();
    refreshController.loadComplete();
  }

  Future<void> addPage() async {
    bool loaded = await paginationController.addPage();
    if (loaded) {
      refreshController.loadComplete();
    } else {
      refreshController.loadNoData();
    }
  }

  @override
  Widget build(BuildContext context) {
    return SmartRefresher(
      controller: refreshController,
      onRefresh: refresh,
      onLoading: addPage,
      enablePullDown: true,
      enablePullUp: true,
      child: child
    );
  }
}

src/common/constants/constants.dart

import 'package:flutter/material.dart';

const shrink = SizedBox.shrink();

const h4gap = SizedBox(height: 4);
const w4gap = SizedBox(width: 4);
const h8gap = SizedBox(height: 8);
const w8gap = SizedBox(width: 8);
const h16gap = SizedBox(height: 16);
const w16gap = SizedBox(width: 16);

const double p4 = 4.0;
const double p8 = 8.0;
const double p16 = 16.0;
const double p24 = 24.0;
const double p32 = 32.0;
const double p40 = 40.0;
const double p48 = 48.0;
const double p56 = 56.0;
const double p64 = 64.0;
const double p72 = 72.0;
const double p80 = 80.0;
const double p88 = 88.0;
const double p96 = 96.0;
const double p104 = 104.0;
const double p112 = 112.0;
const double p120 = 120.0;
const double p128 = 128.0;
const double p136 = 136.0;
const double p144 = 144.0;
const double p152 = 152.0;
const double p160 = 160.0;
const double p168 = 168.0;
const double p176 = 176.0;
const double p184 = 184.0;
const double p192 = 192.0;
const double p200 = 200.0;
const double p208 = 208.0;
const double p216 = 216.0;
const double p224 = 224.0;
const double p232 = 232.0;
const double p240 = 240.0;
const double p248 = 248.0;
const double p256 = 256.0;
const double p264 = 264.0;
const double p272 = 272.0;
const double p280 = 280.0;
const double p288 = 288.0;
const double p296 = 296.0;
const double p304 = 304.0;
const double p312 = 312.0;
const double p320 = 320.0;
const double p328 = 328.0;
const double p336 = 336.0;
const double p344 = 344.0;
const double p352 = 352.0;
const double p360 = 360.0;
const double p368 = 368.0;
const double p376 = 376.0;
const double p384 = 384.0;
const double p392 = 392.0;
const double p400 = 400.0;
const double p408 = 408.0;
const double p416 = 416.0;
const double p424 = 424.0;
const double p432 = 432.0;
const double p440 = 440.0;
const double p448 = 448.0;

src/common/utils/debounce.dart

import 'dart:async';

class Debouncer {
  final int milliseconds;

  Debouncer([this.milliseconds = 800]);

  Timer? _timer;

  debounce(void Function() callback) {
    _timer?.cancel();
    _timer = Timer(Duration(milliseconds: milliseconds), callback);
  }

  dispose() { 
    _timer?.cancel();
  }
}

src/common/widgets/size_controller_widget.dart

import 'dart:ui';

import 'package:client/src/common/log.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';

class SizeControllerWidget extends StatefulWidget {
  const SizeControllerWidget({
    super.key,
    required this.maxHeight,
    required this.builder
  });

  final double maxHeight;
  final WidgetBuilder builder;

  @override
  State<SizeControllerWidget> createState() => _SizeControllerWidgetState();
}

class _SizeControllerWidgetState extends State<SizeControllerWidget> 
  with SingleTickerProviderStateMixin 
  {

  bool isShown = false;

  late AnimationController animationController;
  late Animation<double> gradientAnimation;
  late Animation<double> widgetHeightAnimation;

  @override
  void initState() { 
    super.initState();
    animationController = AnimationController(
      vsync: this, 
      duration: const Duration(seconds: 2),
    );
    gradientAnimation = Tween<double>(begin: widget.maxHeight, end: 0)
      .animate(animationController)
      ..addListener(() {
        setState(() {

        });
      });
    widgetHeightAnimation = Tween<double>(begin: 0, end: 1)
      .animate(animationController)
      ..addListener(() {
        setState(() {

        });
      });
  }
  
  GlobalKey k = GlobalKey();
  
  @override
  Widget build(BuildContext context) {
    // final w = widget.builder(context);
    final w = Container(key: k, height: 100, color: Colors.amber);

    print("${animationController.value} ${gradientAnimation.value} ${widgetHeightAnimation.value}");
    return LayoutBuilder(
      builder: (context, constraints) {
        print('layout = $constraints');
        return InkWell(
          onTap: () {
            setState(() {
              final height = k.currentContext!.size?.height;
              if (height == null) return;
              final diff = height - widget.maxHeight;
              
              if (isShown) {
                isShown = false;
                animationController.reverse(from: height != null ? height / 100 : null);
                printInfo('now it is hidden');
              } else {
                isShown = true;
                animationController.forward(from: height != null ? height / 100 : null);
                printInfo('now it is shown');
              }
            });
          },
          child: w
          // child: isShown 
          //   ? w 
          //   : SizedBox(
          //     height: widget.maxHeight,
          //     child: Viewport(
          //       offset: ViewportOffset.fixed(widget.maxHeight),
          //       slivers: [
          //         SliverFillViewport(
          //           delegate: SliverChildBuilderDelegate((context, index) => w)
          //         )
          //       ],
          //     ),
          //   )
        );
      }
    );
    /*
    return GestureDetector(
      onTap: () {
        setState(() => isShown = !isShown);
      },
      child: Stack(
        children: [
          Positioned.fill(
            child: AnimatedSize(
              curve: Curves.linear,
              duration: const Duration(seconds: 2),
              child: isShown ? w : Viewport(
                offset: ViewportOffset.fixed(widget.maxHeight),
                slivers: [
                  SliverFillViewport(
                    delegate: SliverChildBuilderDelegate((context, index) => w)
                  )
                ],
              ),
            ),
          ),
          Positioned(
            bottom: 0,
            child: Container(
              height: gradientAnimation.value,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Theme.of(context).colorScheme.background,
                    Theme.of(context).colorScheme.background.withAlpha(0),
                  ],
                )
              )
            )
          )
        ]
      )
    );
    */
    // return GestureDetector(
    //   onTap: () {
    //     setState(() {
    //       isShown = !isShown;
    //     });
    //   },
    //   child: isShown 
    //     ? w
    //     : SizedBox(
    //       height: widget.maxHeight,
    //       child: Stack(
    //         children: [
    //           Viewport(
    //             offset: ViewportOffset.fixed(widget.maxHeight),
    //             slivers: [
    //               SliverFillViewport(
    //                 delegate: SliverChildBuilderDelegate((context, index) => w)
    //               )
    //             ],
    //           ),
    //           Positioned.fill(
    //             child: Container(
    //               decoration: BoxDecoration(
    //                 gradient: LinearGradient(
    //                   begin: Alignment.topCenter,
    //                   end: Alignment.bottomCenter,
    //                   tileMode: TileMode.decal,
    //                   stops: [ 0.2, 0.9 ],
    //                   colors: [
    //                     // Theme.of(context).colorScheme.background,
    //                     // Theme.of(context).colorScheme.background.withAlpha(0),
    //                     Colors.red,
    //                     Colors.green,
    //                   ],
    //                 )
    //               ),
    //             )
    //           ),
    //         ]
    //       )
    //     ),
    // );
  }
}

src/common/widgets/my_avatar.dart

import 'package:flutter/material.dart';
import 'package:logger/logger.dart';

class MyAvatar extends StatelessWidget {
  MyAvatar({
    super.key,
    required this.url,
    this.radius
  });

  final String url;
  double? radius;

  final logger = Logger();

  @override
  Widget build(BuildContext context) {
    return CircleAvatar(
      radius: radius ?? 24,
      backgroundImage: NetworkImage(url),
      onBackgroundImageError: (exception, stackTrace) {
        // logger.e("MyAvatar - no image", exception, stackTrace);
      },
    );
  }
}

src/common/widgets/description_form_field.dart

import 'package:client/src/features/localization/application/ll.dart';
import 'package:flutter/material.dart';

class DescriptionFormField extends StatelessWidget {
  const DescriptionFormField({
    super.key,
    this.initialValue,
    this.onChanged
  });

  final String? initialValue;
  final void Function(String newV)? onChanged;

  @override
  Widget build(BuildContext context) {
    final ll = curLl(context)!;
    return SizedBox(
      height: 200,
      child: TextFormField(
        initialValue: initialValue,
        textAlignVertical: TextAlignVertical.top,
        maxLength: 255,
        expands: true,
        maxLines: null,
        minLines: null,
        decoration: InputDecoration(
          labelText: ll.description,
          alignLabelWithHint: true,
        ),
        onChanged: onChanged,
      ),
    );
  }
}

src/common/widgets/see_all_header.dart

import 'package:client/src/common/hardcoded.dart';
import 'package:flutter/material.dart';

import '../../features/localization/application/ll.dart';

class SeeAllHeader extends StatelessWidget {
  const SeeAllHeader({super.key, 
    this.label,
    this.labelText,
    this.onSeeAll,
    this.showSeeAll = true
  });

  final Widget? label;
  final String? labelText;
  final void Function()? onSeeAll;
  final bool showSeeAll;

  Widget _getLabel(BuildContext context) {
    if (label != null) return label!;
    if (labelText != null) {
      return Text(labelText!, 
        style: Theme.of(context).textTheme.headlineSmall
      );
    }
    return const SizedBox.shrink();
  }

  @override
  Widget build(BuildContext context) {
    final ll = curLl(context)!;
    return Row(
      mainAxisAlignment: showSeeAll 
        ? MainAxisAlignment.spaceBetween
        : MainAxisAlignment.start,
      children: [
        _getLabel(context),
        if (showSeeAll) OutlinedButton(
          onPressed: onSeeAll, 
          child: Text(ll.seeAll)
        )
      ]
    );
  }
}

src/common/widgets/show_simple_yes_no_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../features/books/domain/book.dart';
import '../../features/books/presentation/book/book_screen_controller.dart';
import '../../features/localization/application/current_localization.dart';

Future<bool?> showSimpleYesNoDialog(BuildContext context, String title) {
  return showDialog(
    context: context, 
    builder: (context) {
      return Consumer(
        builder: (context, ref, child) {
          final ll = ref.watch(currentLocalizationProvider);
          return SimpleDialog(
            title: Text(title),
            children: [
              SimpleDialogOption(
                child: Text(ll.yes),
                onPressed: () {
                  context.pop(true);
                },
              ),
              SimpleDialogOption(
                child: Text(ll.no),
                onPressed: () {
                  context.pop(false);
                },
              ),
            ]
          );
        }
      );
    }
  );
}

src/common/widgets/google_list_tile.dart

import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';

import 'my_avatar.dart';

class GoogleListTile extends StatelessWidget {
  const GoogleListTile({
    super.key, 
    this.googleSignInAccount,
    this.onRemove
  });

  final void Function()? onRemove;
  final GoogleSignInAccount? googleSignInAccount;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(googleSignInAccount!.displayName ?? ""),
      subtitle: Text(googleSignInAccount!.email),
      trailing: IconButton(
        icon: const Icon(Icons.close),
        onPressed: () {
          if (onRemove != null) onRemove!();
        }
      ),
      leading: MyAvatar(url: googleSignInAccount!.photoUrl ?? "")
    );
  }
}

src/common/widgets/error_handler.dart

import 'dart:io';

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/shared/constants.dart';
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:client/src/common/log.dart';
import 'package:go_router/go_router.dart';

class AppException implements Exception { }

class NotFoundException extends AppException { }

class UnauthenticatedException extends AppException { }

class ConnectionException extends AppException { 
  ConnectionException() {
    printInfo("I am the ConnectionException!");
  }
}

extension GuardX<T> on AsyncValue<T> {
  Future<AsyncValue<T>> guardX(Future<T> Function() callback) async {
    return await AsyncValue.guard(() async {
      try {
        return await callback();
      } on DioError catch (e) {
        printError(e.toString());
        if (e.type == DioErrorType.unknown && e.error is SocketException) {
          printInfo("ConnectionException thrown from guardX");
          throw ConnectionException();
        }
        switch (e.response?.statusCode) {
          case 404:
            printInfo("NotFoundException thrown");
            throw NotFoundException();
          case 500: 
            printInfo("AppException thrown");
            throw AppException();
        }
        rethrow;
      }
    });
  }
}


Widget defaultErrorHandler(Object e, StackTrace st) {
  printError("defaultErrorHandler: ${e.toString()}");
  printError("defaultErrorHandler: ${st.toString()}");
  printError('defaultErrorHandler prints an error type: ${e.runtimeType}');
  if (e is NotFoundException) {
    printInfo("NotFoundException handled");
    return ErrorScreen(
      message: "Not Found".hardcoded,
      title: "Not Found".hardcoded,
    );
  }
  else if (e is ConnectionException) {
    printInfo("ConnectionException handled");
    return ErrorScreen(
      title: "Connection Error".hardcoded,
      message: "Check your Internet connection".hardcoded,
    );
  }
  else if (e is UnauthenticatedException) {
    printInfo("UnatuhenticatedException handled in defaultErrorHandler");
    return ErrorScreen(
      message: 'Unauthenticated.'.hardcoded,
      actionMessage: 'Authenticate'.hardcoded,
      onAction: (context) {
        context.goNamed(MyRoute.auth.name);
      }
    );
  }
  return const ErrorScreen();
}

Widget defaultLoading() {
  return const Scaffold(
    body: Center(
      child: CircularProgressIndicator()
    )
  );
}

class ErrorScreen extends ConsumerWidget {
  const ErrorScreen({
    super.key, 
    this.message = "Error.",
    this.title,
    this.actionMessage,
    this.onAction
  }) : assert(
    actionMessage != null && onAction != null || 
    actionMessage == null && onAction == null
  );

  final String message;
  final String? title;
  final String? actionMessage;
  final void Function(BuildContext context)? onAction;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: (title != null) ? AppBar(
        title: Text(title!),
        centerTitle: true,
      ) : null,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(p8),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.error_outline_sharp,
                color: Colors.red,
                size: 96,
              ),
              h8gap,
              Text(message,
                style: Theme.of(context).textTheme.headlineSmall
              ),
              h8gap,
              if (onAction != null) FilledButton(
                onPressed: () => onAction!(context),
                child: Text(actionMessage!),
              )
            ]
          ),
        )
      )
    );
  }
}

src/common/widgets/list_screen.dart

import 'package:client/src/common/constants/constants.dart';
import 'package:client/src/common/widgets/error_handler.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ListScreen<T> extends ConsumerStatefulWidget {
  const ListScreen({
    super.key, 
    required this.title,
    required this.watch,
    required this.itemBuilder
  });

  final AsyncValue<List<T>> Function(WidgetRef ref) watch;
  final Widget Function(BuildContext context, T item) itemBuilder;
  final String title;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ListScreenState();
}
class _ListScreenState extends ConsumerState<ListScreen> {
  @override
  Widget build(BuildContext context) {
    final state = widget.watch(ref);
    return state.when(
      data: (list) => Scaffold(
        appBar: AppBar(
          title: Text(widget.title),
          centerTitle: true
        ),
        body: ListView.builder(
          itemCount: list.length,
          itemExtent: p8,
          itemBuilder: (context, i) {
            return widget.itemBuilder(context, list[i]);
          }
        )
      ),
      loading: defaultLoading,
      error: defaultErrorHandler
    );
  }
}


src/common/widgets/my_image.dart


import 'dart:io';

import 'package:flutter/material.dart';

import '../constants/constants.dart';

class MyImage extends StatelessWidget {
  const MyImage({
    super.key,
    required this.imageUrl,
    this.placeholderIconSize = 96,
    this.placeholderIcon,
    this.onTap,
    this.size
  });

  final String? imageUrl;
  final double? placeholderIconSize;
  final Widget? placeholderIcon;
  final void Function()? onTap;
  final Size? size;

  Widget _buildImage() {
    return ClipRRect(
      borderRadius: BorderRadius.circular(p8),
      child: (imageUrl != null) 
        ? Container(decoration: BoxDecoration(image: DecorationImage(
            fit: BoxFit.cover,
            image: (RegExp(r'http[s]?:\/\/').hasMatch(imageUrl!)
              ? NetworkImage(imageUrl!)
              : FileImage(File(imageUrl!))) as ImageProvider<Object>
          )))
        : Center(
          child: placeholderIcon ?? Icon(Icons.person_outline, 
            color: Colors.grey, 
            size: placeholderIconSize
          )
        )
    );
  }

  Widget _wrapWithSize(Widget child) {
    return SizedBox.fromSize(size: size, child: child);
  }

  Widget _wrapWithInkWell(Widget child) {
    return Card(
      margin: EdgeInsets.zero,
      child: Stack(
        children: [
          _wrapWithSize(child),
          _wrapWithSize(Material(
            color: Colors.transparent,
            child: InkWell(
              splashColor: Colors.white,
              onTap: onTap,
              borderRadius: BorderRadius.circular(p8),
            ),
          )),
        ]
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return _wrapWithInkWell(_buildImage());
  }
}

src/router/router.dart

import 'package:client/src/common/go_router_refresh_stream.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/common/pagination/pagination_list_widget_controller.dart';
import 'package:client/src/features/auth/application/my_id_provider.dart';
import 'package:client/src/features/auth/data/auth_repository.dart';
import 'package:client/src/features/auth/presentation/auth_screen.dart';
import 'package:client/src/features/books/domain/filters.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_item_widget.dart';
import 'package:client/src/features/books/presentation/book_list/book_list_widget.dart';
import 'package:client/src/features/books/presentation/books/books_screen.dart';
import 'package:client/src/features/chapters/domain/chapter.dart';
import 'package:client/src/features/home/presentation/home_screen.dart';
import 'package:client/src/features/home/presentation/popular_books_screen.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/messages/domain/chat.dart';
import 'package:client/src/features/messages/presentation/chat/chat_screen.dart';
import 'package:client/src/features/messages/presentation/chats/chats_screen.dart';
import 'package:client/src/features/notifications/presentation/notifications_screen.dart';
import 'package:client/src/features/profile/application/currently_edited_profile.dart';
import 'package:client/src/features/profile/domain/profile.dart';
import 'package:client/src/features/profile/presentation/authors/author_widget.dart';
import 'package:client/src/features/profile/presentation/profile/profile_screen.dart';
import 'package:client/src/common/pagination/simple_pagination_list_screen.dart';
import 'package:client/src/router/scaffold_with_navigation.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/pagination_list_callback_factory.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:logger/logger.dart';

import '../features/books/data/book_repository.dart';
import '../features/books/domain/book.dart';
import '../features/books/presentation/book/book_screen.dart';
import '../features/books/presentation/book_filters/books_filters_screen.dart';
import '../features/books/presentation/books/profile_books_screen.dart';
import '../features/books/presentation/edit_book/edit_book_screen.dart';
import '../features/chapters/presentation/chapter/chapter_screen.dart';
import '../features/chapters/presentation/chapters/book_chapters_screen.dart';
import '../features/chapters/presentation/edit_chapter/edit_chapter_screen.dart';
import '../features/profile/presentation/authors/authors_screen.dart';
import '../features/profile/presentation/bookmarks/bookmarks_screen.dart';
import '../features/profile/presentation/edit_profile_screen/edit_profile_screen.dart';
import '../features/profile/presentation/profile/subscribers_screen.dart';
import '../features/profile/presentation/profile/subscriptions_screen.dart';
import '../features/settings/presentation/settings_screen.dart';

extension MyRoutePath on MyRoute {
  String get path {
    switch (this) {
      case MyRoute.root:
        return '/';
      case MyRoute.auth:
        return '/auth';

      case MyRoute.home:
        return '/home';
      case MyRoute.chats:
        return '/chats';
      // case MyRoute.authors: return '/authors';
      case MyRoute.profiles:
        return '/profiles';
      case MyRoute.books:
        return '/books';
      case MyRoute.bookFilters:
        return '/books/filters';
      case MyRoute.myProfile:
        return '/myProfile';

      case MyRoute.settings:
        return '/settings';
      case MyRoute.notifications:
        return '/notifications';
      case MyRoute.bookmarks:
        return '/bookmarks';

      case MyRoute.chat:
        return '/chats/:id';
      case MyRoute.book:
        return '/books/:id';
      case MyRoute.editBook:
        return '/books/:id/edit';
      case MyRoute.addBook:
        return '/profiles/:id/books/add';
      case MyRoute.profile:
        return '/profiles/:id';
      case MyRoute.editProfile:
        return '/profiles/:id/edit';
      case MyRoute.profileBooks:
        return '/profiles/:id/books';
      case MyRoute.subscribers:
        return '/profiles/:id/subscribers';
      case MyRoute.subscriptions:
        return '/profiles/:id/subscriptions';

      case MyRoute.chapters: 
        return '/books/:id/chapters';
      case MyRoute.addChapter:
        return '/books/:id/chapters/add';
      case MyRoute.chapter:
        return '/chapters/:id';
      case MyRoute.editChapter:
        return '/chapters/:id/edit';

      case MyRoute.blocked:
        return '/blocked';

      case MyRoute.popularBooks:
        return '/popularBooks';
      case MyRoute.popularAuthors:
        return '/popularAuthors';
    }
  }
}

final routerProvider = Provider((ref) {
  final rootNavigatorKey = GlobalKey<NavigatorState>();
  final shellNavigatorKey = GlobalKey<NavigatorState>();

  return GoRouter(
    navigatorKey: rootNavigatorKey,
    // redirect: (context, state) {
    //   final isLoggedIn = ref.watch(authRepositoryProvider).currentUser != null;
    //   print("redirect isLoggedIn = $isLoggedIn state.location = ${state.location}");
    //   if (isLoggedIn && (state.location == '/auth' || state.location == '/')) {
    //     print('redirect to /home');
    //     return '/home';
    //   } else if (!isLoggedIn && state.location != '/auth') {
    //     print('redirect to /auth');
    //     return '/auth';
    //   }
    //   return null;
    // },
    // refreshListenable: GoRouterRefreshStream(ref.watch(authRepositoryProvider).userChanges),
    initialLocation: MyRoute.home.path,
    routes: [
      ShellRoute(
          navigatorKey: shellNavigatorKey,
          builder: (context, state, child) {
            return ScaffoldWithNavigation(child: child);
          },
          routes: [
            GoRoute(
              path: MyRoute.home.path,
              name: MyRoute.home.name,
              pageBuilder: (context, state) {
                return NoTransitionPage(
                  key: state.pageKey,
                  child: HomeScreen(),
                );
              },
            ),
            GoRoute(
                path: MyRoute.chats.path,
                name: MyRoute.chats.name,
                pageBuilder: (context, state) {
                  return NoTransitionPage(
                    key: state.pageKey,
                    child: ChatsScreen(),
                  );
                }),
            GoRoute(
                path: MyRoute.books.path,
                name: MyRoute.books.name,
                pageBuilder: (context, state) {
                  return NoTransitionPage(
                    key: state.pageKey,
                    child: const BooksScreen(),
                  );
                },
                routes: [
                  GoRoute(
                      path: 'filters',
                      name: MyRoute.bookFilters.name,
                      pageBuilder: (context, state) {
                        return const NoTransitionPage(
                            child: BooksFiltersScreen());
                      })
                ]),
            GoRoute(
              path: MyRoute.book.path,
              name: MyRoute.book.name,
              pageBuilder: (context, state) {
                return NoTransitionPage(
                    child:
                        BookScreen(bookId: state.params['id'] as String));
              },
              routes: [
                GoRoute(
                  path: 'edit',
                  name: MyRoute.editBook.name,
                  pageBuilder: (context, state) {
                    return NoTransitionPage(
                      child: EditBookScreen(book: state.extra as Book),
                    );
                  },
                ),
                GoRoute(
                  path: 'chpaters',
                  name: MyRoute.chapters.name,
                  pageBuilder: (context, state) {
                    return NoTransitionPage(
                      child: BookChaptersScreen(
                        bookId: state.params['id'] as String,
                        book: state.extra as Book
                      ),
                    );
                  },
                  routes: [
                    GoRoute(
                      path: 'add',
                      name: MyRoute.addChapter.name,
                      pageBuilder: (context, state) {
                        return NoTransitionPage(
                          child: EditChapterScreen.add(
                            forBook: state.extra as Book
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ],
            ),
            GoRoute(
              path: MyRoute.profiles.path,
              name: MyRoute.profiles.name,
              pageBuilder: (context, state) {
                return NoTransitionPage(
                  key: state.pageKey,
                  child: AuthorsScreen(),
                );
              },
            ),
            GoRoute(
                path: MyRoute.profile.path,
                name: MyRoute.profile.name,
                builder: (context, state) {
                  Logger()
                      .i("GoRoute(/profile/:id) id='${state.params['id']}'");
                  String profileId = state.params['id'] as String;
                  print('go to this $profileId profileId');
                  return Consumer(builder: (context, ref, child) {
                    return ProfileScreen(profileId: profileId);
                  });
                },
                routes: [
                  GoRoute(
                      path: 'edit',
                      name: MyRoute.editProfile.name,
                      builder: (context, state) {
                        return ProviderScope(
                          overrides: [
                            currentlyEditedProfileProvider
                                .overrideWith((ref) {
                              return state.extra as Profile;
                            })
                          ],
                          child: const EditProfileScreen(),
                        );
                      }),
                  GoRoute(
                      path: 'subscribers',
                      name: MyRoute.subscribers.name,
                      builder: (context, state) {
                        return SubscribersScreen(
                            profileId: state.params['id'] as String);
                      }),
                  GoRoute(
                      path: 'subscriptions',
                      name: MyRoute.subscriptions.name,
                      builder: (context, state) {
                        return SubscriptionsScreen(
                          profileId: state.params['id'] as String,
                        );
                      }),
                  GoRoute(
                      path: 'books',
                      name: MyRoute.profileBooks.name,
                      builder: (context, state) {
                        return ProfileBooksScreen(
                            ofProfile: state.params['id']!);
                      },
                      routes: [
                        GoRoute(
                            path: 'add',
                            name: MyRoute.addBook.name,
                            pageBuilder: (context, state) {
                              return NoTransitionPage(
                                  child: EditBookScreen.add(
                                      state.params['id']!) // id - profile id
                                  );
                            })
                      ]
                  )
                ]),
            GoRoute(
              path: MyRoute.myProfile.path,
              name: MyRoute.myProfile.name,
              pageBuilder: (context, state) {
                return NoTransitionPage(
                  key: state.pageKey,
                  child: Consumer(builder: (context, ref, child) {
                    // я передаю сюда ref.watch(myIdProvider) вместо того чтобы
                    // делать это в середине, потому что я использую ProfileScreen
                    // так же для того чтобы просматривать чужие профили
                    return ProfileScreen(profileId: ref.watch(myIdProvider));
                  }),
                );
              },
            ),
            GoRoute(
                path: MyRoute.notifications.path,
                name: MyRoute.notifications.name,
                pageBuilder: (context, state) {
                  return NoTransitionPage(
                      key: state.pageKey, child: const NotificationsScreen());
                }),
            GoRoute(
                path: MyRoute.bookmarks.path,
                name: MyRoute.bookmarks.name,
                pageBuilder: (context, state) {
                  return NoTransitionPage(
                      key: state.pageKey, child: BookmarksScreen());
                }),
            GoRoute(
              path: MyRoute.settings.path,
              name: MyRoute.settings.name,
              pageBuilder: (context, state) {
                return NoTransitionPage(
                    key: state.pageKey, child: const SettingsScreen());
              },
            ),
          ]),
      GoRoute(
        parentNavigatorKey: rootNavigatorKey,
        path: MyRoute.popularBooks.path,
        name: MyRoute.popularBooks.name,
        pageBuilder: (context, state) {
          return NoTransitionPage(
            child: PopularBooksScreen()
          );
        }
      ),
      GoRoute(
        parentNavigatorKey: rootNavigatorKey,
        path: MyRoute.chapter.path,
        name: MyRoute.chapter.name,
        pageBuilder: (context, state) {
          return NoTransitionPage(
            child: ChapterScreen(
              chapterId: state.params['id'] as String,
            ),
          );
        },
        routes: [
          GoRoute(
            parentNavigatorKey: rootNavigatorKey,
            path: 'edit',
            name: MyRoute.editChapter.name,
            pageBuilder: (context, state) {
              return NoTransitionPage(
                child: EditChapterScreen(chapter: state.extra as Chapter)
              );
            }
          )
        ]
      ),
      GoRoute(
          parentNavigatorKey: rootNavigatorKey,
          path: MyRoute.chat.path,
          name: MyRoute.chat.name,
          pageBuilder: (context, state) {
            Chat chat = state.extra as Chat;
            return NoTransitionPage(
                key: state.pageKey, child: ChatScreen(chat: chat));
          }),
      GoRoute(
        parentNavigatorKey: rootNavigatorKey,
        path: MyRoute.root.path,
        name: MyRoute.root.name,
        builder: (context, state) => Scaffold(
          appBar: AppBar(
            title: const Text("'/'"),
          ),
        ),
      ),
      GoRoute(
          parentNavigatorKey: rootNavigatorKey,
          path: MyRoute.auth.path,
          name: MyRoute.auth.name,
          builder: (context, state) {
            return ProviderScope(overrides: [
              currentlyEditedProfileProvider.overrideWith((ref) {
                return Profile();
              })
            ], child: const AuthScreen());
          }),
      GoRoute(
        parentNavigatorKey: rootNavigatorKey,
        path: MyRoute.blocked.path,
        name: MyRoute.blocked.name,
        builder: (context, state) {
          return const BlockedScreen();
        }
      )
    ]
  );
});

class BlockedScreen extends ConsumerWidget {
  const BlockedScreen({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Account is blocked.', 
              style: Theme.of(context).textTheme.displaySmall,
              textAlign: TextAlign.center,
            ),
            FilledButton.icon(
              onPressed: () {
                ref.watch(authRepositoryProvider).signOut();
              }, 
              icon: const Icon(Icons.logout_rounded),
              label: Text('Sign Out'.hardcoded)
            )
          ],
        )
      )
    );
  }
}


src/router/scaffold_with_navigation.dart

import 'package:client/src/common/build_context_ext.dart';
import 'package:client/src/common/hardcoded.dart';
import 'package:client/src/common/log.dart';
import 'package:client/src/features/home/presentation/home_screen_app_bar.dart';
import 'package:client/src/features/localization/application/current_localization.dart';
import 'package:client/src/features/messages/presentation/chats/chats_screen_app_bar.dart';
import 'package:client/src/features/profile/presentation/authors/authors_screen_app_bar.dart';
import 'package:client/src/router/router.dart';
import 'package:client/src/router/scaffold_with_bottom_nav_bar_item.dart';
import 'package:client/src/router/shell_scaffold_key.dart';
import 'package:client/src/shared/constants.dart';
import 'package:client/src/shared/scaffold_messanger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';

import '../common/constants/constants.dart';
import '../features/books/presentation/books/books_screen_app_bar.dart';

class ScaffoldWithNavigation extends ConsumerStatefulWidget {
  const ScaffoldWithNavigation({
    super.key, 
    required this.child
  });

  final Widget child;

  @override
  ConsumerState<ConsumerStatefulWidget> createState() => _ScaffoldWithNavigationState();
}
class _ScaffoldWithNavigationState extends ConsumerState<ScaffoldWithNavigation> {

  late List<ScaffoldWithNavigationTabItem> primaryTabs;
  late List<ScaffoldWithNavigationDrawerItem> primaryDrawerTabs;
  late List<ScaffoldWithNavigationDrawerItem> secondaryDrawerTabs;

  GlobalKey<ScaffoldState> get scaffoldKey => ref.watch(shellScaffoldKeyProvider);

  void initTabs() {
    final ll = ref.read(currentLocalizationProvider);

    primaryTabs = [
      ScaffoldWithNavigationTabItem(
        initialLocation: MyRoute.home.path,
        icon: const Icon(Icons.home_outlined),
        selectedIcon: const Icon(Icons.home),
        label: ll.screenTitle.home,
      ),
      ScaffoldWithNavigationTabItem(
        initialLocation: MyRoute.chats.path,
        icon: const Icon(Icons.message_outlined),
        selectedIcon: const Icon(Icons.message),
        label: ll.screenTitle.messages,
      ),
      ScaffoldWithNavigationTabItem(
        initialLocation: MyRoute.books.path,
        icon: const Icon(Icons.book_outlined),
        selectedIcon: const Icon(Icons.book),
        label: ll.screenTitle.books,
      ),
      ScaffoldWithNavigationTabItem(
        initialLocation: MyRoute.profiles.path,
        icon: const Icon(Icons.people_alt_outlined),
        selectedIcon: const Icon(Icons.people_alt),
        label: ll.screenTitle.authors,
      ),
      ScaffoldWithNavigationTabItem(
        initialLocation: MyRoute.myProfile.path,
        icon: const Icon(Icons.person_outline),
        selectedIcon: const Icon(Icons.person),
        label: ll.screenTitle.profile,
      ),
    ];

    primaryDrawerTabs = primaryTabs.map(
      (t) => ScaffoldWithNavigationDrawerItem(
        initialLocation: t.initialLocation, 
        icon: t.icon, 
        selectedIcon: t.selectedIcon,
        label: Text(t.label)
      )
    ).toList();

    secondaryDrawerTabs = [
      ScaffoldWithNavigationDrawerItem(
        initialLocation: MyRoute.notifications.path,
        icon: const Icon(Icons.notifications_outlined),
        selectedIcon: const Icon(Icons.notifications),
        label: Text(ll.screenTitle.notifications),
      ),
      ScaffoldWithNavigationDrawerItem(
        initialLocation: MyRoute.bookmarks.path,
        icon: const Icon(Icons.bookmark_outline),
        selectedIcon: const Icon(Icons.bookmark),
        label: Text(ll.screenTitle.bookmarks),
      ),
      ScaffoldWithNavigationDrawerItem(
        initialLocation: MyRoute.settings.path,
        icon: const Icon(Icons.settings_outlined),
        selectedIcon: const Icon(Icons.settings),
        label: Text(ll.screenTitle.settings),
      ),
    ];
  }

  @override
  void initState() {
    super.initState();
    
    initTabs();
  }

  String get curLocation => GoRouter.of(context).location;
  int get drawerSelected {
    return [...primaryDrawerTabs, ...secondaryDrawerTabs].indexWhere(
      (t) => t.initialLocation.startsWith(curLocation)
    );
  }
  int get tabSelected {
    int selected = primaryTabs.indexWhere(
      (t) => t.initialLocation.startsWith(curLocation)
    );
    if (selected == -1 || selected >= primaryTabs.length) return 0;
    return selected;
  }

  void onDestinationSelected(BuildContext context, int index) {
    if (index == drawerSelected) return;

    if (index < primaryTabs.length) {
      context.go(primaryTabs[index].initialLocation);
    } else if (drawerSelected >= primaryTabs.length) {
      context.pushReplacement(
        [...primaryDrawerTabs, ...secondaryDrawerTabs][index]
          .initialLocation);
    } else {
      context.push(
        [...primaryDrawerTabs, ...secondaryDrawerTabs][index]
          .initialLocation);
    }
    scaffoldKey.currentState?.closeDrawer();
  }

  bool ext = true;

  @override
  Widget build(BuildContext context) {
    ref.listen(currentLocalizationProvider, (p, n) => initTabs());
    printInfo("build ScaffoldWithNavigation $drawerSelected $tabSelected");

    if (context.isMobile || context.isSmallTablet || context.isTablet) {
      return Scaffold(
        key: scaffoldKey,
        drawer: NavigationDrawer(
          selectedIndex: drawerSelected,
          children: [
            h16gap,
            ...primaryDrawerTabs,
            const Divider(),
            ...secondaryDrawerTabs
          ],
          onDestinationSelected: (index) {
            onDestinationSelected(context, index);
          },
        ),
        body: widget.child,
        bottomNavigationBar: (!secondaryDrawerTabs.map((t) => t.initialLocation).contains(curLocation)) 
          ? NavigationBar(
            selectedIndex: tabSelected,
            onDestinationSelected: (index) {
              onDestinationSelected(context, index);
            },
            destinations: primaryTabs
          ) 
          : null
      );
    }

    return Scaffold(
      key: scaffoldKey,
      body: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (drawerSelected >= 0) NavigationRail(
            labelType: NavigationRailLabelType.all,
            destinations: [
              ...[...primaryDrawerTabs, ...secondaryDrawerTabs]
                .map((i) => i.toRailDestination())
            ],
            selectedIndex: drawerSelected,
            onDestinationSelected: (index) {
              onDestinationSelected(context, index);
            },
          ),
          Expanded(
            child: widget.child
          )
        ]
      ),
    );
  }
}

src/router/scaffold_with_bottom_nav_bar_item.dart

import 'package:flutter/material.dart';

mixin RouteDestination {
  String get initialLocation;
}

/// Representation of a tab item in a [ScaffoldWithNavBar]
/// Ну, тут ничего необычного. Просто итемы с раутом, по которому нужно перейти. 
class ScaffoldWithNavigationTabItem extends NavigationDestination 
    with RouteDestination {
  @override
  final String initialLocation;

  const ScaffoldWithNavigationTabItem({
    super.key, 
    required this.initialLocation,
    required Widget icon, 
    Widget? selectedIcon, 
    String? label
  }) : super(
    selectedIcon: selectedIcon,
    icon: icon, 
    label: label ?? "some"
  );
}

class ScaffoldWithNavigationDrawerItem extends NavigationDrawerDestination 
    with RouteDestination {
  @override
  final String initialLocation;

  const ScaffoldWithNavigationDrawerItem({
    super.key,
    required this.initialLocation,
    required Widget icon,
    Widget? selectedIcon,
    required Widget label
  }) : super(
    selectedIcon: selectedIcon,
    icon: icon,
    label: label
  );

  toRailDestination() {
    return NavigationRailDestination(
      selectedIcon: selectedIcon,
      icon: icon, 
      label: label
    );
  }
}

src/router/menu_button_leading.dart

import 'package:client/src/common/build_context_ext.dart';
import 'package:client/src/router/shell_scaffold_key.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class MenuButtonLeading extends ConsumerWidget {
  const MenuButtonLeading({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (context.isMobile || context.isSmallTablet || context.isTablet)  {
      return IconButton(
        icon: const Icon(Icons.menu_rounded),
        onPressed: () {
          final state = ref.watch(shellScaffoldKeyProvider).currentState!;
          state.isDrawerOpen 
            ? state.closeDrawer() 
            : state.openDrawer();
        }
      );
    }
    else {
      return const SizedBox.shrink();
    }
  }
}

src/router/shell_scaffold_key.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final shellScaffoldKeyProvider = Provider((ref) => GlobalKey<ScaffoldState>());

